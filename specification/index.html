<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>WT-106 Amendment 9</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#wt-106---data-model-template-for-cwmp-endpoints-and-usp-agents">WT-106 - Data Model Template for CWMP Endpoints and USP Agents</a><ul>
<li><a href="#introduction">1 Introduction</a></li>
<li><a href="#terminology">1.1 Terminology</a></li>
<li><a href="#document-conventions">1.2 Document Conventions</a></li>
</ul></li>
<li><a href="#architecture">2 Architecture</a><ul>
<li><a href="#data-hierarchy">2.1 Data Hierarchy</a><ul>
<li><a href="#data-hierarchy-requirements">2.1.1 Data Hierarchy Requirements</a></li>
<li><a href="#the-supported-data-model-and-the-instantiated-data-model">2.1.2 The Supported Data Model and the Instantiated Data Model</a></li>
</ul></li>
<li><a href="#object-versioning">2.2 Object Versioning</a><ul>
<li><a href="#requirements-for-compatible-versions">2.2.1 Requirements for Compatible Versions</a></li>
<li><a href="#version-notation">2.2.2 Version Notation</a></li>
</ul></li>
<li><a href="#profiles">2.3 Profiles</a><ul>
<li><a href="#scope-of-profiles">2.3.1 Scope of Profiles</a></li>
<li><a href="#multiple-profile-support">2.3.2 Multiple Profile Support</a></li>
<li><a href="#profile-versions">2.3.3 Profile Versions</a></li>
<li><a href="#baseline-profiles">2.3.4 Baseline Profiles</a></li>
<li><a href="#types-of-requirements-in-a-profile">2.3.5 Types of Requirements in a Profile</a></li>
</ul></li>
<li><a href="#deprecated-and-obsoleted-items">2.4 DEPRECATED and OBSOLETED Items</a><ul>
<li><a href="#requirements-for-deprecated-items">2.4.1 Requirements for DEPRECATED Items</a></li>
<li><a href="#requirements-for-obsoleted-items">2.4.2 Requirements for OBSOLETED Items</a></li>
</ul></li>
</ul></li>
<li><a href="#object-definitions">3 Object Definitions</a><ul>
<li><a href="#general-notation">3.1 General Notation</a></li>
<li><a href="#data-types-and-representation">3.2 Data Types and Representation</a><ul>
<li><a href="#date-and-time-rules">3.2.1 Date and Time Rules</a></li>
<li><a href="#comma-separated-lists">3.2.2 Comma-separated Lists</a></li>
<li><a href="#parameters-that-reference-parameters-or-objects">3.2.3 Parameters that Reference Parameters or Objects</a></li>
<li><a href="#units-conventions">3.2.4 Units Conventions</a></li>
<li><a href="#default-maximum-string-length">3.2.5 Default Maximum String Length</a></li>
</ul></li>
<li><a href="#vendor-specific-parameters-and-objects">3.3 Vendor-Specific Parameters and Objects</a></li>
</ul></li>
<li><a href="#normative-references">4 Normative References</a></li>
<li><a href="#annex-a.-cwmp-data-model-definition-xml-schema">Annex A. CWMP Data Model Definition XML Schema</a><ul>
<li><a href="#a.1-introduction">A.1 Introduction</a><ul>
<li><a href="#a.1.1-character-encoding-and-character-set">A.1.1 Character Encoding and Character Set</a></li>
</ul></li>
<li><a href="#a.2-normative-information">A.2 Normative Information</a><ul>
<li><a href="#a.2.1-importing-dm-instances">A.2.1 Importing DM Instances</a></li>
<li><a href="#a.2.2-descriptions">A.2.2 Descriptions</a></li>
<li><a href="#a.2.3-data-types">A.2.3 Data Types</a></li>
</ul></li>
<li><a href="#glossary-abbreviations-and-bibliography">2.4 Glossary, Abbreviations and Bibliography</a><ul>
<li><a href="#glossary">2.4.1 Glossary</a></li>
<li><a href="#abbreviations">2.4.2 Abbreviations</a></li>
<li><a href="#bibliography">2.4.3 Bibliography</a></li>
<li><a href="#a.2.5-components">A.2.5 Components</a></li>
<li><a href="#a.2.6-root-and-service-objects">A.2.6 Root and Service Objects</a></li>
<li><a href="#a.2.7-parameters">A.2.7 Parameters</a></li>
<li><a href="#a.2.8-commands-usp-only">A.2.8 Commands (USP Only)</a></li>
</ul></li>
<li><a href="#a.2.9-events-usp-only">### A.2.9 Events (USP Only)</a><ul>
<li><a href="#a.2.10-objects">A.2.10 Objects</a></li>
<li><a href="#a.2.11-profiles">A.2.11 Profiles</a></li>
<li><a href="#a.2.12-modifications">A.2.12 Modifications</a></li>
</ul></li>
<li><a href="#a.3-dm-schema">A.3 DM Schema</a></li>
</ul></li>
<li><a href="#annex-b.-cwmp-device-type-xml-schema">Annex B. CWMP Device Type XML Schema</a><ul>
<li><a href="#b.1-introduction">B.1 Introduction</a></li>
<li><a href="#b.2-normative-information">B.2 Normative Information</a><ul>
<li><a href="#b.2.1-importing-dm-instances">B.2.1 Importing DM Instances</a></li>
<li><a href="#b.2.2-features">B.2.2 Features</a></li>
</ul></li>
<li><a href="#b.3-dt-schema">B.3 DT Schema</a></li>
</ul></li>
<li><a href="#annex-c---requirements-for-bbf-standard-data-models">Annex C - Requirements for BBF Standard Data Models</a><ul>
<li><a href="#c.1-introduction">C.1 Introduction</a></li>
<li><a href="#c.2-character-encoding-and-character-set">C.2 Character Encoding and Character Set</a></li>
<li><a href="#c.3-xml-usage">C.3 XML Usage</a><ul>
<li><a href="#c.3.1-data-model-item-names">C.3.1 Data Model Item Names</a></li>
<li><a href="#c.3.2-dm-and-dmr-schema-versions">C.3.2 DM and DMR Schema Versions</a></li>
<li><a href="#c.3.3-schemalocation-attribute">C.3.3 SchemaLocation Attribute</a></li>
<li><a href="#c.3.4-spec-attribute">C.3.4 Spec Attribute</a></li>
<li><a href="#c.3.5-file-attribute">C.3.5 File Attribute</a></li>
<li><a href="#c.3.6-import-element">C.3.6 Import Element</a></li>
<li><a href="#c.3.7-bibliography-reference-element">C.3.7 Bibliography Reference Element</a></li>
<li><a href="#c.4-general-formatting">C.4 General Formatting</a></li>
</ul></li>
<li><a href="#c.5-initial-xml-comment-formatting">C.5 Initial XML Comment Formatting</a><ul>
<li><a href="#c.5.1-one-line-summary">C.5.1 One-line Summary</a></li>
<li><a href="#c.5.2-summary-section">C.5.2 Summary Section</a></li>
</ul></li>
</ul></li>
<li><a href="#appendix-i---html-data-model-reports">Appendix I - HTML Data Model Reports</a><ul>
<li><a href="#i.1-introduction">I.1 Introduction</a></li>
<li><a href="#i.2-report-types">I.2 Report Types</a></li>
<li><a href="#i.3-report-layout">I.3 Report Layout</a></li>
<li><a href="#i.4-data-model-definition">I.4 Data Model Definition</a></li>
</ul></li>
</ul>
</nav>
<h1 id="wt-106---data-model-template-for-cwmp-endpoints-and-usp-agents">WT-106 - Data Model Template for CWMP Endpoints and USP Agents</h1>
<p><strong>Issue:</strong> <strong>1 Amendment 8</strong></p>
<p><strong>Issue Date:</strong> <strong>TBD</strong> <strong>2018</strong></p>
<p><strong>Notice</strong></p>
<p>The Broadband Forum is a non-profit corporation organized to create guidelines for broadband network system development and deployment. This has been approved by members of the Forum. This is subject to change. This is copyrighted by the Broadband Forum, and all rights are reserved. Portions of this may be copyrighted by Broadband Forum members.</p>
<p><strong>Intellectual Property</strong></p>
<p>Recipients of this are requested to submit, with their comments, notification of any relevant patent claims or other intellectual property rights of which they may be aware that might be infringed by any implementation of this , or use of any software code normatively referenced in this , and to provide supporting documentation.</p>
<p><strong>Terms of Use</strong></p>
<p><strong>1. License</strong></p>
<p>Broadband Forum hereby grants you the right, without charge, on a perpetual, non-exclusive and worldwide basis, to utilize the for the purpose of developing, making, having made, using, marketing, importing, offering to sell or license, and selling or licensing, and to otherwise distribute, products complying with the , in all cases subject to the conditions set forth in this notice and any relevant patent and other intellectual property rights of third parties (which may include members of Broadband Forum). This license grant does not include the right to sublicense, modify or create derivative works based upon the Technical Report except to the extent this Technical Report includes text implementable in computer code, in which case your right under this License to create and modify derivative works is limited to modifying and creating derivative works of such code. For the avoidance of doubt, except as qualified by the preceding sentence, products implementing this Technical Report are not deemed to be derivative works of the Technical Report.</p>
<p><strong>2. NO WARRANTIES</strong></p>
<p><strong>THIS</strong> <strong>Technical Report IS BEING OFFERED WITHOUT ANY WARRANTY WHATSOEVER, AND IN PARTICULAR, ANY WARRANTY OF NONINFRINGEMENT IS EXPRESSLY DISCLAIMED. ANY USE OF THIS</strong> <strong>Technical Report SHALL BE MADE ENTIRELY AT THE IMPLEMENTER'S OWN RISK, AND NEITHER THE BROADBAND FORUM, NOR ANY OF ITS MEMBERS OR SUBMITTERS, SHALL HAVE ANY LIABILITY WHATSOEVER TO ANY IMPLEMENTER OR THIRD PARTY FOR ANY DAMAGES OF ANY NATURE WHATSOEVER, DIRECTLY OR INDIRECTLY, ARISING FROM THE USE OF THIS</strong> <strong>Technical Report.</strong></p>
<p><strong>3. THIRD PARTY RIGHTS</strong> Without limiting the generality of Section 2 above, BROADBAND FORUM ASSUMES NO RESPONSIBILITY TO COMPILE, CONFIRM, UPDATE OR MAKE PUBLIC ANY THIRD PARTY ASSERTIONS OF PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS THAT MIGHT NOW OR IN THE FUTURE BE INFRINGED BY AN IMPLEMENTATION OF THE Technical Report IN ITS CURRENT, OR IN ANY FUTURE FORM. IF ANY SUCH RIGHTS ARE DESCRIBED ON THE Technical Report, BROADBAND FORUM TAKES NO POSITION AS TO THE VALIDITY OR INVALIDITY OF SUCH ASSERTIONS, OR THAT ALL SUCH ASSERTIONS THAT HAVE OR MAY BE MADE ARE SO LISTED.</p>
<p>The text of this notice must be included in all copies of this Technical Report.</p>
<p><strong><br />
</strong></p>
<p><strong>Revision History</strong></p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 5%" />
<col style="width: 6%" />
<col style="width: 39%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th>Issue Number</th>
<th>Approval Date</th>
<th>Publication Date</th>
<th>Issue Editor</th>
<th>Changes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Issue 1</td>
<td>September 2005</td>
<td></td>
<td>Jeff Bernstein, 2Wire Christele Bouchat, Alcatel Tim Spets, Westell</td>
<td>Original</td>
</tr>
<tr class="even">
<td>Issue 1 Amendment 1</td>
<td>November 2006</td>
<td></td>
<td>Jeff Bernstein, 2Wire John Blackford, 2Wire Mike Digdon, SupportSoft Heather Kirksey, Motive William Lupton, 2Wire Anton Okmianski, Cisco</td>
<td>Clarification of original document</td>
</tr>
<tr class="odd">
<td>Issue 1 Amendment 2</td>
<td>November 2008</td>
<td></td>
<td>William Lupton, 2Wire Håkan Westin, Tilgin</td>
<td>Addition of data model definition XML Schema and normative XML common object and component definitions</td>
</tr>
<tr class="even">
<td>Issue 1 Amendment 3</td>
<td>September 2009</td>
<td></td>
<td>William Lupton, 2Wire Håkan Westin, Tilgin</td>
<td>Addition of device type XML Schema</td>
</tr>
<tr class="odd">
<td>Issue 1 Amendment 4</td>
<td>February 2010</td>
<td></td>
<td>William Lupton, 2Wire Paul Sigurdson, Broadband Forum</td>
<td>Moved data model definitions to TR-181 Issue 1</td>
</tr>
<tr class="even">
<td>Issue 1 Amendment 5</td>
<td>November 2010</td>
<td></td>
<td>Paul Sigurdson, Broadband Forum</td>
<td>Replaced definitions of named data types such as IPAddress with references to normative XML. Minor changes to DM Schema (v1.3) and DT Schema (v1.1).</td>
</tr>
<tr class="odd">
<td>Issue 1 Amendment 6</td>
<td>July 2011</td>
<td></td>
<td>Sarah Banks, Cisco Andrea Colmegna, FASTWEB Tim Spets, Motorola Mobility</td>
<td>Removed definition of proxying, now defined in TR-069. Removed Common objects. Alias Parameter Requirements added.</td>
</tr>
</tbody>
</table>
<p>Comments or questions about this Broadband Forum should be directed to <a href="mailto:info@broadband-forum.org" class="email">info@broadband-forum.org</a>.</p>
<p><strong>Editors</strong></p>
<p>William Lupton, Broadband Forum</p>
<p>Jean-Didier Ott, Orange</p>
<p><strong>Broadband User Services Work Area Directors</strong></p>
<p>Jason Walls, QA Cafe</p>
<p>John Blackford, Arris</p>
<p><strong>Executive Summary</strong></p>
<p>TR-106 specifies data model guidelines to be followed by all CWMP 2 Endpoints and USP 13 Agents. These guidelines include structural requirements for the data hierarchy, requirements for versioning of data models, and requirements for defining profiles.</p>
<p>In addition, TR-106 defines an XML Schema that as far as possible embodies these guidelines, and which is used for defining all CWMP and USP data models. This makes data model definitions rigorous, and helps to reduce the danger that different implementations will interpret data model definitions in different ways.</p>
<p>TR-106 also defines an XML Schema that allows a device to describe its supported CWMP data models. This description is both specific and detailed, allowing a Controller to know exactly what is supported by the device, including any vendor-specific objects and parameters. Use of this Schema enhances interoperability and significantly eases the integration of new devices with a Controller. USP uses a different mechanism (GetSupportedDM message) for the same purpose. That mechanism is specified in TR-369 13.</p>
<p><strong>Important warning</strong></p>
<p>The InternetGatewayDevice:1 (TR-098) and Device:1 (TR-181 Issue 1) Root Data Models are now DEPRECATED and any reference to elements specific to those models have been removed from this document.</p>
<p>The last revision of TR-106 to be used with those models is TR-106 Amendment 7.</p>
<p>TR-157 data models Components have been incorporated into Device:2.12. TR-157 is therefore also DEPRECATED.</p>
<h2 id="introduction">1 Introduction</h2>
<p><strong>CWMP</strong></p>
<p>TR-069 defines the generic requirements of the CPE WAN Manage­ment Protocol (CWMP) methods which can be applied to any CWMP Endpoint. It is intended to support a variety of different functionalities to manage a collection of CPE, including the following primary capabilities:</p>
<ul>
<li><p>Auto-configuration and dynamic service provisioning</p></li>
<li><p>Software/firmware image management</p></li>
<li><p>Status and performance monitoring</p></li>
<li><p>Diagnostics</p></li>
</ul>
<p>The ability to manage the home network remotely has a number of benefits including reducing the costs associated with activation and support of broadband services, improving time-to-market for new products and services, and improving the user experience.</p>
<p>The following figure places TR-069 in the end-to-end management architecture:</p>
<p><img src="./figure-1.png" /></p>
<p>Figure 1 - CWMP Positioning in the End-to-End Architecture</p>
<p>The ACS is a server that resides in the network and manages devices in the subscriber premises. It uses the methods, or RPCs, defined in TR-069 to get and set the state of the device, initiate diagnostic tests, download and upload files, and manage events. Some portions of this state are common across managed devices and some are relevant only to certain device types or services.</p>
<p><strong>USP</strong></p>
<p>The <a href="http://usp.technology/">User Services Platform</a> is made of a network of USP Controllers and USP Agents to allow applications to manipulate service elements (i.e. objects). It represents the evolution of CWMP into the following use cases:</p>
<ul>
<li><p>Improvements on TR-069 based on deployment experience</p></li>
<li><p>Multi-tenant management of a given endpoint (that is, manipulation by multiple controllers)</p></li>
<li><p>Application to additional market spaces, including consumer electronics and the Internet of Things</p></li>
</ul>
<p>An agent exposes service elements to one or more controllers, either directly or by proxy. An application could use a Controller to manage a provider controlled system, as in a CWMP ACS, or to act as a user portal in the cloud, on a gateway, or accessed through a smart phone. Agents and controllers can also be used in tandem to create a peer-to-peer network of smart applications, such as an automated smart home.</p>
<p><img src="./figure-2.png" /></p>
<p>Figure 2 - USP Architecture Overview</p>
<p>USP was designed in a modular manner, and can make use of the CWMP data model and data model schema in order to represent an evolution of CWMP into the world of consumer electronics, virtual services, and the Internet of Things. As such, this document describes how to use the data model schema in both the context of CWMP and USP.</p>
<p><strong>Specification Structure</strong></p>
<p>Figure 3 shows the overall specification structure for the CWMP 2 and USP 13 family of standards (as currently defined). Please note that this will gradually become out of date as new documents are published.</p>
<p><img src="./figure-3.png" /></p>
<p>Figure 3 - Specification Structure</p>
<p>TR-069 2 defines the generic requirements of the CWMP methods which can be applied to any CWMP Endpoint. TR-369 13 does the same for USP Agents. TR-106 (this document) specifies a baseline object structure to be supported by any CWMP Endpoint or USP Agent (referred to generically as an <em>Agent</em>). It specifies how to structure and define data models, which are collections of objects and parameters on which the generic methods act to configure, diagnose, and monitor the state of specific devices and services. The actual data models are defined in their own specifications.</p>
<p>For a particular type of device, it is expected that the baseline defined in a document such as TR-181i2 10 would be augmented with additional objects and parameters specific to the device type. The data model used in any Agent MUST follow the guidelines described in this document. These guidelines include the following aspects:</p>
<ul>
<li><p>Structural requirements for the data hierarchy</p></li>
<li><p>Requirements for versioning of data models</p></li>
<li><p>Requirements for defining profiles</p></li>
</ul>
<p>In addition, this document defines two XML Schemas:</p>
<ul>
<li><p>An XML Schema that as far as possible embodies these guidelines, and which is used for defining all CWMP and USP data models. This makes data model definitions rigorous, and helps to reduce the danger that different implementations will interpret data model definitions in different ways.</p></li>
<li><p>An XML Schema that allows a device to describe its supported CWMP data models. This description is both specific and detailed, allowing an ACS to know exactly what is supported by the CPE, including any vendor-specific objects and parameters. Use of this Schema enhances interoperability and significantly eases the integration of new devices with an ACS.</p>
<p>Please note that USP uses a different mechanism (GetSupportedDM message) for the same purpose. It is specified in TR-369 13.</p></li>
</ul>
<h2 id="terminology">1.1 Terminology</h2>
<p>The following terminology is used throughout this Technical Report.</p>
<p><strong>ACS</strong> Auto-Configuration Server. This is a component in the broadband network responsible for <em>CWMP</em> auto-configuration of the <em>CPE</em> for advanced services.</p>
<p><strong>Agent</strong> A generic term that refers (as appropriate) to either a <em>CWMP Endpoint</em> or to a <em>USP Agent</em>.</p>
<p><strong>BBF</strong> The Broadband Forum.</p>
<p><strong>Base Supported Data Model</strong> The <em>Data Model</em> that is supported by all <em>CPE</em> of a given make, model and firmware version. This refers to the <em>Objects,</em> <em>Parameters, Commands</em> and/or <em>Events</em> that have code support in the current firmware.</p>
<p><strong>CPE</strong> Customer Premises Equipment; refers (as appropriate) to any <em>CWMP</em>-enabled 2 or <em>USP</em>-enabled 13 device and therefore covers both Internet Gateway devices and LAN-side end devices.</p>
<p><strong>Command</strong> A named element allowing a <em>USP Controller</em> to execute an operation on a <em>USP Agent</em>. This concept does not apply to <em>CWMP</em>, which uses <em>Objects</em> and/or <em>Parameters</em> to simulate operations.</p>
<p><strong>Component</strong> A named collection of <em>Objects,</em> <em>Parameters, Commands, Events</em> and/or <em>Profiles</em> that can be included anywhere within a <em>Data Model</em>.</p>
<p><strong>Controller</strong> A generic term that refers (as appropriate) to either a <em>CWMP ACS</em> or a <em>USP Controller</em>.</p>
<p><strong>Current Supported Data Model</strong> The <em>Data Model</em> that is currently supported by an individual <em>CPE</em>, i.e. the <em>Base Supp­ort­ed Data Model</em> plus any additional <em>Objects</em>, <em>Parameters</em>, <em>Commands</em> and/or <em>Events</em> supported by extra mod­ules that have been installed on the <em>CPE</em>. This refers to the <em>Objects</em>, <em>Parameters,</em> <em>Commands</em> and/or <em>Events</em> that have code support in the <em>CPE</em>.</p>
<p><strong>CWMP</strong> <em>CPE</em> WAN Management Protocol. Defined in TR-069 2, CWMP is a communication protocol between an <em>ACS</em> and CWMP-enabled <em>CPE</em> that defines a mechanism for secure auto-configuration of a <em>CPE</em> and other <em>CPE</em> management functions in a common framework.</p>
<p><strong>CWMP Endpoint</strong> A <em>CWMP</em> termination point used by a CWMP-enabled <em>CPE</em> for communication with the <em>ACS.</em></p>
<p><strong>Data Model</strong> A hierarchical set of <em>Objects</em>, <em>Parameters</em>, <em>Commands</em> and/or <em>Events</em> that define the managed <em>Objects</em> access­ible via a particular <em>Agent</em>.</p>
<p><strong>Device</strong> Used here as a synonym for <em>CPE</em>.</p>
<p><strong>DM Instance</strong> Data Model Schema instance document. This is an XML document that conforms to the <em>DM Schema</em> and to any additional rules specified in or referenced by the <em>DM Schema</em>.</p>
<p><strong>DM Schema</strong> Data Model Schema. This is the XML Schema 9 that is used for defining data models for use with <em>CWMP</em> and <em>USP</em>.</p>
<p><strong>DT Instance</strong> Device Type Schema instance document. This is an XML document that conforms to the <em>DT Schema</em> and to any additional rules specified in or referenced by the <em>DT Schema</em>. <em>This concept is useful for both CWMP and USP as an offline design tool, but only CWMP uses it at run-time (via the SupportedDataModel Object; see Section</em> <em>2.1.2).</em></p>
<p><strong>DT Schema</strong> Device Type Schema. This is the XML Schema 9 that is used for describing a <em>Device</em>’s <em>Supported Data Model</em>. <em>This concept is useful for both CWMP and USP as an offline design tool, but only CWMP uses it at run-time (via the SupportedDataModel Object; see Section</em> <em>2.1.2).</em></p>
<p><strong>Event</strong> An indication that something of interest has happened that requires the <em>Agent</em> to notify the <em>Controller</em>.</p>
<p><strong>Instantiated Data Model</strong> The <em>Data Model</em> that currently exists on an individual <em>CPE</em>. This refers to the <em>Object</em> instances, <em>Para­met­ers</em>, <em>Commands</em> and/or <em>Events</em> that currently exist within the data model. It can be thought of as the <em>Current Supported Data Model</em> with all the “{i}” placeholders expanded to be the actual <em>Instance Numbers</em>. For example, “Device.Services.ABCService.{i}.” in the <em>Current Supported Data Model</em> might correspond to “Device.Services.ABCService.1.” and “Device.­Services.­ABC­Serv­ice.­2.” in the <em>Instantiated Data Model</em>.</p>
<p><strong>Instance Alias</strong> A writeable string that uniquely identifies an instance within a <em>Multi-Instance Object</em></p>
<p><strong>Instance Identifier</strong> A value that uniquely identifies an instance within a <em>Multi-Instance Object</em>. It is either an <em>Instance Number</em> or an <em>Instance Alias</em>.</p>
<p><strong>Instance Number</strong> A read-only positive integer (&gt;=1) that uniquely identifies an instance within a <em>Multi-Instance Object.</em></p>
<p><strong>Mountable Object</strong> An <em>Object</em> that is defined in a <em>DM Instance</em> as a direct child of the <em>Root Object</em>, but that can also exist as a child of a <em>Mount Point</em> in the <em>Instantiated Data Model</em> of a <em>USP Agent</em>. This concept does not apply to <em>CWMP</em>.</p>
<p><strong>Mount Point</strong> An <em>Object</em> that is defined in a <em>DM Instance</em> as being able to have <em>Mountable Objects</em> as children in the <em>Instantiated Data Model</em> of a <em>USP Agent</em>. By extension, one of the instances of that object in the <em>Instantiated Data Model</em>. This concept does not apply to <em>CWMP</em>.</p>
<p><strong>Multi-Instance Object</strong> An <em>Object</em> that can have multiple instances, all of which are located at the same level within the name hierarchy. Each instance is identified by an <em>Instance Identifier</em>.</p>
<p><strong>Object</strong> An internal node in the name hierarchy, i.e., a node that can have <em>Object</em>, <em>Parameter</em>, <em>Command</em> and/or <em>Event</em> children. An <em>Object</em> name is a <em>Path Name</em>.</p>
<p><strong>Parameter</strong> A name-value pair that represents part of a <em>CPE</em> or <em>USP Agent</em>’s configuration or status. A Parameter name is a <em>Path Name</em>.</p>
<p><strong>Path Name</strong> A name that has a hierarchical structure similar to files in a directory, with each level separated by a “.” (dot). References an <em>Object</em>, <em>Parameter,</em> <em>Command</em> or <em>Event</em>.</p>
<p><strong>Profile</strong> A named collection of requirements relating to a given <em>Root Object</em>, <em>Service Object</em> or <em>Component</em>.</p>
<p><strong>RPC</strong> Remote Procedure Call.</p>
<p><strong>Root Object</strong> The top-level <em>Object</em> of a <em>CPE</em>’s <em>Data Model</em> that contains all of the manageable <em>Objects</em>. The name of the Root <em>Object</em> is “Device.”.</p>
<p><strong>Service Element</strong> A Service Element represents a piece of service functionality that is exposed by an Agent, usually represented by one or more Objects.</p>
<p><strong>Service Object</strong> The top-most <em>Object</em> associated with a specific service within which all <em>Objects</em>, <em>Parameters,</em> <em>Commands</em> and <em>Events</em> associated with the service are contained.</p>
<p><strong>Supported Data Model</strong> Refers to either <em>Base Supported Data Model</em> or <em>Current Supported Data Model</em>, depending on the context.</p>
<p><strong>URI</strong> Uniform Resource Identifier.</p>
<p><strong>URL</strong> Uniform Resource Locator.</p>
<p><strong>USP</strong> Universal Service Platform. Defined in TR-369, USP is an evolution of CWMP that allows applications to manipulate Service Elements in a network of Controllers and Agents.</p>
<p><strong>USP Agent</strong> A USP Agent is a USP Endpoint that exposes Service Elements to one or more USP Controllers.</p>
<p><strong>USP Controller</strong> A USP Controller is a USP Endpoint that manipulates Service Elements through one or more USP Agents.</p>
<p><strong>USP Endpoint</strong> A USP Endpoint is a termination point for a USP message.</p>
<h2 id="document-conventions">1.2 Document Conventions</h2>
<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in 1.</p>
<h1 id="architecture">2 Architecture</h1>
<p>All elements described hereunder apply to both CWMP and USP, unless specifically mentioned otherwise.</p>
<h2 id="data-hierarchy">2.1 Data Hierarchy</h2>
<p>The data model for a Agent will follow a common set of structural requirements. The detailed structure depends on the nature of the Agent.</p>
<p>An Agent’s data model will always have a single Root Object, which will be called “Device.”.</p>
<p>The Root Object contains three types of sub-elements: the Objects defined in TR-181i2 10, Components defined in TR-181i2 or other specifications such as TR-143 8, and a single “Services” object that contains all Service Objects associated with specific services.</p>
<p>A single Agent might include more than one Service Object. For example, a device that serves both as a VoIP endpoint and a game device, might include both VoIP-specific and game-specific Service Objects.</p>
<p>A single Agent might also include more than one instance of the same type of Service Object. An example of when this might be appropriate is an Agent that provides an instance of the TR-140 12 StorageService for each of the device’s attached disks.</p>
<h3 id="data-hierarchy-requirements">2.1.1 Data Hierarchy Requirements</h3>
<p>A CWMP or USP data model MUST adhere to the following structural requirements:</p>
<ol type="1">
<li><p>A root data model definition MUST contain exactly one Root Object, called “Device.”.</p></li>
<li><p>A Root Object definition MUST contain exactly one “Services.” object.</p></li>
<li><p>A service data model definition MUST define an object hierarchy that starts just under the “Device.Services.” object.</p></li>
<li><p>For each Multi-Instance Object defined, a data model MUST also define a corresponding parameter indicating the number of instances of the Multi-Instance Object. The name of this parameter MUST be the name of the object concatenated with “NumberOfEntries”. This parameter MUST appear in the same object as the Multi-Instance Object it is related to.</p></li>
</ol>
<p>Formally, the top level of the data hierarchy is defined as follows:</p>
<pre><code>Element = &quot;Device&quot;
        | &quot;Device.&quot; TR-181DeviceObject
        | &quot;Device.Services.&quot; ServiceObject &quot;NumberOfEntries&quot;
        | &quot;Device.Services.&quot; ServiceObject &quot;.{i}&quot;

TR-181DeviceObject = // As defined in TR-181i2 10, e.g. &quot;UserInterface&quot; or &quot;ManagementServer&quot;

ServiceObject = // As defined in other specs, e.g. TR-140 12</code></pre>
<h3 id="the-supported-data-model-and-the-instantiated-data-model">2.1.2 The Supported Data Model and the Instantiated Data Model</h3>
<p>There is a distinction between an Agent’s Supported Data Model and its Instantiated Data Model.</p>
<ul>
<li><p>The Supported Data Model is those Objects and/or Parameters that have code support in the Agent.</p></li>
<li><p>The Instantiated Data Model is those Object instances and/or Parameters that currently exist.</p></li>
</ul>
<p>TR-181i2 10 defines a SupportedDataModel Object that allows an Agent to indicate its Supported Data Model to a Controller, which assists the Controller in managing that device.</p>
<p>The Supported­Data­Model object has the following properties:</p>
<ol type="1">
<li><p>It contains a list of URLs, each of which allows the Controller to determine details of part of the Supported Data Model.</p></li>
<li><p>When the Supported Data Model changes, e.g. because software is loaded or unloaded, entries are added to or removed from this list of URLs.</p></li>
</ol>
<p>This object is not used with USP. TR-369 13 defines the GetSupportedDM message to provide this information.</p>
<h2 id="object-versioning">2.2 Object Versioning</h2>
<p>To allow the definition of a Service Object or Root Object to change over time, the definition of a Service Object or Root Object MUST have an explicitly specified version.</p>
<p>Version numbering of Service Objects and Root Objects is defined to use a major/minor version numbering convention. The object version is defined as a pair of integers, where one integer represents the major version, and the second integer represents the minor version. The version MUST be written with the two integers separated by a dot (Major.Minor).</p>
<p>The first version of a given object SHOULD be defined as version “1.0”.</p>
<p>For each subsequent version of the object, if the later version is compatible with the previous version, then the major version SHOULD remain unchanged, and the minor version SHOULD be incremented by one. For example, the next compatible version after “2.17” would be “2.18”. The requirements for a version to be considered compatible with an earlier version are described in Section 2.2.1.</p>
<p>For each subsequent version of the object, if the later version is not compatible with the previous version, then the major version MUST increment by one, and the minor version MAY reset back to zero. For example, the next incompatible version after “2.17” might be “3.0”.</p>
<h3 id="requirements-for-compatible-versions">2.2.1 Requirements for Compatible Versions</h3>
<p>For one version of an object to be considered compatible with another version, the later version MUST be a strict superset of the earlier version. Using major/minor versioning, this requirement applies only between minor versions that share the same major version.</p>
<p>More specifically, this requires the following of the later version with respect to all earlier versions to which it is to be compatible:</p>
<ul>
<li><p>The later version MAY add objects and parameters not previously in any earlier version, but MUST NOT remove objects or parameters already defined in earlier versions.</p></li>
<li><p>The later version MUST NOT modify the definition of any parameter or object already defined in an earlier version (unless the original definition was clearly in error and has to be modified as an erratum or clarified through a corrigendum process).</p></li>
<li><p>The later version MUST NOT require any of the objects or parameters that have been added since the earliest compatible version to be explicitly operated upon by the Controller to ensure proper operation of the device (except those functions specifically associated with functionality added in later versions). That is, the later version will accommodate a Controller that knows nothing of elements added in later versions.</p></li>
</ul>
<p>The goal of the above definition of compatibility is intended to ensure bi-directional compatibility between a Controller and Agent. Specifically that:</p>
<ul>
<li><p>If a Controller supports only an earlier version of an object as compared to the version supported by the Agent, the Controller can successfully manage that object in the Agent as if it were the earlier version.</p></li>
<li><p>If an Agent supports only an earlier version of an object as compared to the version supported by a Controller, the Controller can successfully manage that object in the Agent as if it were the later version (without support for new components defined only in later versions).</p></li>
</ul>
<h3 id="version-notation">2.2.2 Version Notation</h3>
<p>For objects, the following notation is defined to identify specific versions:</p>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 63%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th>Notation</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ObjectName:Major.Minor</td>
<td>Refers to a specific version of the object.</td>
<td>Device:2.0</td>
</tr>
<tr class="even">
<td>ObjectName:Major</td>
<td>Refers to any minor version of the object with the specified major version.</td>
<td>Device:2</td>
</tr>
<tr class="odd">
<td>ObjectName</td>
<td>Refers to any version of the object.</td>
<td>Device</td>
</tr>
</tbody>
</table>
<p>Note that the version notation defined here is <em>only</em> to be used for purposes of documentation. The actual names of objects and parameters in the data model MUST NOT include version numbers.</p>
<h2 id="profiles">2.3 Profiles</h2>
<p>Note: Originally, profiles were seen as a means of limiting the variability that a Controller needs to accommodate among various devices that it might manage. This feature is now provided:</p>
<ul>
<li><p>For CWMP, by the TR-181i2 10 SupportedDataModel object (see Section 2.1.2) and associated Device Type XML documents (DT Instances).</p></li>
<li><p>For USP, by the TR-369 13 GetSupportedDM message.</p></li>
</ul>
<p>A profile is a named collection of requirements associated with a given object. An Agent can adhere to zero or more profiles. Adherence to a profile means that the Agent supports all of the requirements defined by that profile. The use of profiles gives Service Providers a shorthand means of specifying data model support requirements.</p>
<p>The following sections define the conventions to be used when defining profiles associated with Data Models.</p>
<h3 id="scope-of-profiles">2.3.1 Scope of Profiles</h3>
<p>A given profile is defined only in the context of a specific Service Object or Root Object with a specific major version. For each profile definition, the specific object name and major version to which the profile is to apply MUST be explicitly identified.</p>
<p>A profile’s name MUST be unique among profiles defined for the same object and major version, but a name MAY be reused to define a different profile for a distinct combination of object name and major version. For example, if we define profile “A” associated with object “X:2” (major version 2 of object X), the same name “A” might be used to define a different profile for object “Y:1” or for object “X:3”.</p>
<p>A given profile is defined in association with a minimum minor version of a given object. The minimum REQUIRED version of an object is the minimum version that includes all of the REQUIRED elements defined by the profile. For each profile definition, the specific minimum version MUST be explicitly identified.</p>
<h3 id="multiple-profile-support">2.3.2 Multiple Profile Support</h3>
<p>For a given type of Service Object or Root Object, multiple profiles MAY be defined. Profiles MAY be defined that have either independent or overlapping requirements.</p>
<h3 id="profile-versions">2.3.3 Profile Versions</h3>
<p>To allow the definition of a profile to change over time, the definition of every profile MUST have an associated version number.</p>
<p>Version numbering of profiles is defined to use a minor-only version numbering convention. That is, for a given profile name, each successive version MUST be compatible with all earlier versions. Any incompatible change to a profile MUST use a different profile name.</p>
<p>For one version of a profile to be considered compatible with another version, the later version MUST be a strict superset of the earlier version. This requires the following of the later version with respect to all earlier versions to which it is to be compatible:</p>
<ul>
<li><p>The later version MAY add requirements that were not in earlier versions of the profile, but MUST NOT remove requirements.</p></li>
<li><p>The later version MAY remove one or more conditions that had previously been placed on a requirement. For example, if a previous profile REQUIRED X only if condition A was True, then the later profile might require X unconditionally.</p></li>
</ul>
<p>For profiles, the following notation is defined to identify specific versions:</p>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 58%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th>Notation</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ProfileName:Version</td>
<td>Refers to a specific version of the profile.</td>
<td>Baseline:1</td>
</tr>
<tr class="even">
<td>ProfileName</td>
<td>Refers to any version of the profile.</td>
<td>Baseline</td>
</tr>
</tbody>
</table>
<p>ProfileName MUST start with a letter or underscore, and subsequent characters MUST be letters, digits, underscores or hyphens. The terms “letter” and “digit” are as defined in Appendix B of the XML specification 6.</p>
<p>Hyphens can easily be confused with the discretionary hyphens that are sometimes inserted by hyphenation algorithms. For this reason, ProfileName SHOULD NOT include any hyphens. Additionally, ProfileName SHOULD NOT start with an underscore. In BBF standards, ProfileName will always start with an upper-case letter and will never include any hyphens or underscores (see C.3.1 for the corresponding normative requirement).</p>
<h3 id="baseline-profiles">2.3.4 Baseline Profiles</h3>
<p>For every Service Object (and Root Object) there SHOULD be at least one profile defined. In many cases it is desirable to define a Baseline profile that indicates the minimum requirements REQUIRED for any device that supports that Object.</p>
<h3 id="types-of-requirements-in-a-profile">2.3.5 Types of Requirements in a Profile</h3>
<p>Because a profile is defined within the context of a single Object (and major version), all of the requirements associated with the profile MUST be specific to the data model associated with that object.</p>
<p>Profile requirements can include any of the following types of requirements associated with an Object’s data model:</p>
<ul>
<li><p>A requirement for read support of a Parameter.</p></li>
<li><p>A requirement for write support of a Parameter.</p></li>
<li><p>A requirement for support of a Command.</p></li>
<li><p>A requirement for support of a sub-Object contained within the overall Object.</p></li>
<li><p>A requirement for the ability to add or remove instances of a sub-Object.</p></li>
<li><p>A requirement to support active notification for a Parameter.</p></li>
<li><p>A requirement to support access control for a given Parameter.</p></li>
</ul>
<p>For each of the requirement categories listed above, a profile can define the requirement unconditionally, or can place one or more conditions on the requirement. For example, a profile might require that a Parameter be supported for reading only if the device supports some other Parameter or Object (one that is not itself REQUIRED by the profile). Such conditions will be directly related to the data model of the overall object associated with the profile.</p>
<p>Because a device has to be able to support multiple profiles, all profiles MUST be defined such that they are non-contradictory. As a result, profiles MUST only define minimum requirements to be met, and MUST NOT specify negative requirements. That is, profiles will not include requirements that specify something that is not to be supported by the device, or requirements that exclude a range of values.</p>
<h2 id="deprecated-and-obsoleted-items">2.4 DEPRECATED and OBSOLETED Items</h2>
<p>The key word “DEPRECATED” in a data model definition is to be interpreted as follows: This term refers to an object, parameter or parameter value that is defined in the current version of the standard but is meaningless, inappropriate, or otherwise unnecessary. It is intended that such objects, parameters or parameter values will be removed from the next major version of the data model. Requirements on how to interpret or implement deprecated objects, parameters or parameter values are given below. For more information on how to interpret or implement specific deprecated objects, parameters or parameter values, refer to the definition of the object or parameter.</p>
<p>The key word “OBSOLETED” in a data model definition is to be interpreted as follows: This term refers to an object, parameter or parameter value that meets the requirements for being deprecated, and in addition is obsolete. Such objects, parameters or parameter values can be removed from a later minor version of a data model, or from a later version of a profile, without this being regarded as breaking backwards compatibility rules. Requirements on how to interpret or implement obsoleted objects, parameters or parameter values are given below. For more information on how to interpret or implement specific obsoleted objects, parameters or parameter values, refer to the definition of the object or parameter.</p>
<h3 id="requirements-for-deprecated-items">2.4.1 Requirements for DEPRECATED Items</h3>
<p>This section defines requirements that apply to all DEPRECATED objects, parameters and parameter values unless specifically overridden by the object or parameter definition.</p>
<p>Data model requirements:</p>
<ol type="1">
<li><p>The definition of a DEPRECATED parameter, object or parameter value MUST include an explanation of why the item is deprecated.</p></li>
<li><p>The definition of a DEPRECATED parameter, object or parameter value MAY specify further requirements relating to the item; such requirements MAY override general Agent or Controller requirements regarding DEPRECATED elements specified in TR-069 2 or TR-369</p>
<ol start="13" type="1">
<li></li>
</ol></li>
</ol>
<p>Agent requirements:</p>
<ol type="1">
<li><p>A DEPRECATED parameter MUST have a value which is valid for its data type and fulfils any range (for numeric parameters), length (for string, base64 or hexBinary parameters) and enumerated value (for string parameters) requirements.</p></li>
<li><p>Detailed behavioral requirements for a DEPRECATED parameter, e.g. that its value is a unique key, MAY be ignored by the Agent.</p></li>
<li><p>The Agent MUST, if such operations are permitted by the data model definition, permit creation of DEPRECATED objects, modification of DEPRECATED parameters, and setting of DEPRECATED parameter values. However, it MAY choose not to apply such changes to its operational state.</p></li>
<li><p>Regardless of whether DEPRECATED changes are applied to the Agent’s operational state, a read of a DEPRECATED writable parameter SHOULD return the value that was last written, i.e. the Agent is expected to store the value even if it chooses not to apply it to its operational state.</p></li>
<li><p>The Agent MAY reject an attempt by a Controller to set any parameter to a DEPRECATED value.</p></li>
</ol>
<p>Controller requirements:</p>
<ol type="1">
<li><p>The Controller SHOULD NOT create DEPRECATED objects, modify DEPRECATED parameters, or set DEPRECATED parameter values.</p></li>
<li><p>The Controller SHOULD ignore DEPRECATED objects, parameters and parameter values.</p></li>
<li><p>The Controller SHOULD NOT set a DEPRECATED parameter to a value that is invalid for its data type or fails to fulfill any range (for numeric parameters), length (for string, base64 or hexBinary parameters) or enumerated value (for string parameters) requirements.</p></li>
<li><p>The Controller SHOULD NOT set any parameter to a DEPRECATED value.</p></li>
</ol>
<h3 id="requirements-for-obsoleted-items">2.4.2 Requirements for OBSOLETED Items</h3>
<p>This section defines requirements that apply to all OBSOLETED objects, parameters or parameter values unless specifically overridden by the object or parameter definition.</p>
<p>An OBSOLETED object, parameter or parameter value MUST meet all the requirements of the previous section. In addition, the following requirements apply.</p>
<ol type="1">
<li><p>An OBSOLETED object, parameter or parameter value MAY be removed from a later minor version of a data model without this being regarded as breaking backwards compatibility rules.</p></li>
<li><p>An OBSOLETED object, parameter or parameter value MUST NOT be removed from the current version of a profile, but MAY be removed from a later version of a profile without this being regarded as breaking backwards compatibility rules.</p></li>
<li><p>A data model definition MUST include a list of those OBSOLETED objects, parameters or parameter values that have been removed from the data model or from its profiles. This is to prevent future namespace conflicts.</p></li>
</ol>
<h1 id="object-definitions">3 Object Definitions</h1>
<h2 id="general-notation">3.1 General Notation</h2>
<p>Parameter names use a hierarchical form similar to a directory tree. The name of a particular Parameter is represented by the concatenation of each successive node in the hierarchy separated with a “.” (dot), starting at the trunk of the hierarchy and leading to the leaves. When specifying a partial path, indicating an intermediate node in the hierarchy, the trailing “.” (dot) is always used as the last character.</p>
<p>Parameter names MUST be treated as case sensitive. The name of each node in the hierarchy MUST start with a letter or underscore, and subsequent characters MUST be letters, digits, underscores or hyphens. The terms “letter” and “digit” are as defined in Appendix B of the XML specification 6.</p>
<p>Hyphens can easily be confused with the discretionary hyphens that are sometimes inserted by hyphenation algorithms. For this reason, the names of nodes in the hierarchy SHOULD NOT include any hyphens. Additionally, the names of nodes in the hierarchy SHOULD NOT start with underscores. In BBF standards, the names of nodes in the hierarchy always start with an upper-case letter and never include any hyphens or underscores (see C.3.1 for the corresponding normative requirement).</p>
<p>Where multiple instances of an object can occur, the placeholder node name {i} is shown. In actual use, this placeholder is to be replaced by an Instance Identifier.</p>
<h2 id="data-types-and-representation">3.2 Data Types and Representation</h2>
<p>Parameters make use of a limited subset of the default SOAP data types. The supported data types are defined by the DM Schema and are also listed in A.2.3.</p>
<p>The named data types that specify the representations of IP addresses, MAC addresses etc, are defined in a DM Instance document (see Annex A). The XML file with those definitions and the corresponding HTML file can be found in the <a href="https://cwmp-data-models.broadband-forum.org/#Data%20Model%20Data%20Types">data model resources page</a>. Note that this DM Instance defines named data types that are expected to be used in several data model definitions; it is possible to define local named data types in any DM Instance document.</p>
<p>The following sub-sections specify additional rules governing parameter value representation within XML documents.</p>
<h3 id="date-and-time-rules">3.2.1 Date and Time Rules</h3>
<p>All times MUST be expressed in UTC (Universal Coordinated Time) unless explicitly stated otherwise in the definition of a parameter of this type.</p>
<p>If absolute time is not available to the Agent, it SHOULD instead indicate the relative time since boot, where the boot time is assumed to be the beginning of the first day of January of year 1, or <code>0001 01 01T00:00:00</code>. For example, 2 days, 3 hours, 4 minutes and 5 seconds since boot would be expressed as <code>0001 01 03T03:04:05</code>. Relative time since boot MUST be expressed using an untimezoned representation. Any untimezoned value with a year value less than 1000 MUST be interpreted as a relative time since boot.</p>
<p>If the time is unknown or not applicable, the following value representing “Unknown Time” MUST be used: <code>0001-01-01T00:00:00Z</code>. For an infinite timeline, the following value representing “Infinite Time” MUST be used: <code>9999-12-31T23:59:59Z</code>.</p>
<p>Any dateTime value other than one expressing relative time since boot (as described above) MUST use UTC timezoned representation (that is, it MUST include a timezone suffix of “<code>Z</code>”, “<code>-00:00</code>” or “<code>+00:00</code>”).</p>
<h3 id="comma-separated-lists">3.2.2 Comma-separated Lists</h3>
<p>For strings that are defined to contain comma-separated lists, the format is defined as follows. Between every pair of successive items in a comma-separated list there MUST be a separator. The separator MUST include exactly one comma character, and MAY also include one or more whitespace characters before or after the comma. The entire separator, including any whitespace characters, MUST NOT be considered part of the list items it separates. The last item in a comma-separated list MUST NOT be followed with a separator. Individual items in a comma-separated list MUST NOT include a whitespace or comma character within them. Any whitespace or comma characters within an item value MUST be escaped using percent-encoding as specified in Section 2.1/RFC 3986 5.</p>
<p>It is possible to create a list of lists, although other solutions SHOULD be preferred when possible. If a string contains a list of lists, the rules of the previous paragraph imply that the comma separators of the inner list will be percent encoded. For example, a three element list with elements “a”, “b,c” (a two element list) and “d” could be represented as “a,b%2Cc,d”. In order to avoid the need to percent encode the inner separators, inner lists MAY be “protected” by placing them within square brackets, e.g. the above list could be represented as “a,[b,c],d”. In order to avoid ambiguity (a Controller that didn’t understand the new syntax would interpret “a,[b,c],d” as the four element list “a”, “[b”, “c]”, “d”), the data type and/or parameter definition MUST explicitly state that the new syntax is supported (A.2.3.1, A.2.7.1).</p>
<h3 id="parameters-that-reference-parameters-or-objects">3.2.3 Parameters that Reference Parameters or Objects</h3>
<p>For string parameters that are defined to contain the hierarchical Path Name of an object (or for each item in parameters that are defined to contain comma-separated lists of object Path Names), the representation of the object name MUST NOT include a trailing “dot.” An example of a parameter of this kind in the TR- 181i2 10 Device:2 data model is ­Device.InterfaceStack.{i}.LowerLayer. For this parameter, the following is an example of a properly formed value:</p>
<p><code>Device.Ethernet.Interface.1</code></p>
<p>Path Names in parameter values MUST always be full Path Names. For CWMP there is an exception such that a path that begins with a dot is relative to the Root or Service Object. For example, in the Device Root Object, a parameter value of “.DeviceInfo” always means “Device.DeviceInfo”. NOTE: This exception does NOT hold for USP.</p>
<p>In order to be able to use reference parameters as unique keys (A.2.10.1), their Path Names MUST conceptually be converted to full Path Names before being compared. For example, in the Device Root Object, “.DeviceInfo.” and “Device.DeviceInfo.” would compare as equal. If a reference parameter is list-valued, i.e. it is a list of Path Names or Instance Numbers, the parameter value MUST conceptually be regarded as a set when being compared, i.e. the comparison has to ignore the item order and any repeated items. For example, “1,2,1” and “2,1” would compare as equal because both reference instances 1 and 2.</p>
<p>References are defined as strong or weak in the data model. A strong reference always either references an existing parameter or object, or else is a null reference. On the other hand, a weak reference does not necessarily reference an existing parameter or object.</p>
<h3 id="units-conventions">3.2.4 Units Conventions</h3>
<p>For numeric parameters whose values are defined in terms of units, bit and byte-related units will always refer to powers of 2. For example, a kilobyte will always be 1024 bytes, a megabyte always 1024 * 1024 bytes, etc.</p>
<h3 id="default-maximum-string-length">3.2.5 Default Maximum String Length</h3>
<p>For string-valued parameters, a maximum length is either explicitly indicated or implied by the size of the elements composing the string. For strings in which the content is an enumeration, the longest enumerated value determines the maximum length. Similarly, for strings in which the content is a pattern, the longest possible matching value determines the maximum length. For strings in which the content is a list, the maximum number of items and the individual item lengths can help to determine the maximum string length.</p>
<h2 id="vendor-specific-parameters-and-objects">3.3 Vendor-Specific Parameters and Objects</h2>
<p>A vendor MAY extend the standardized parameter list with vendor-specific parameters and objects. Vendor-specific parameters and objects MAY be defined either in a separate naming hierarchy or within the standardized naming hierarchy.</p>
<p>The name of a vendor-specific parameter or object not contained within another vendor-specific object MUST have the form:</p>
<blockquote>
<p>X_&lt;VENDOR&gt;_VendorSpecificName</p>
</blockquote>
<p>In this definition &lt;VENDOR&gt; is a unique vendor identifier, which MAY be either an OUI or a domain name. The OUI or domain name used for a given vendor-specific parameter MUST be one that is assigned to the organization that defined this parameter (which is not necessarily the same as the vendor of the Agent). An OUI is an organizationally unique identifier as defined in 3, which MUST be formatted as a six-hexadecimal-digit string using all upper-case letters and including any leading zeros. A domain name MUST be upper case with each dot (“.”) replaced with a hyphen or underscore.</p>
<p>The VendorSpecificName MUST NOT contain a “.” (period) or a space character.</p>
<blockquote>
<p><em>Note – the use of the string “X_” to indicate a vendor-specific parameter implies that no standardized parameter can begin with “X_”.</em></p>
</blockquote>
<p>The name of a vendor-specific parameter or object that is contained within another vendor-specific object which itself begins with the prefix described above need not itself include the prefix.</p>
<p>The full Path Name of a vendor-specific parameter or object MUST NOT exceed 256 characters in length.</p>
<p>Below are some example vendor-specific parameter and object names:</p>
<pre><code>Device.UserInterface.X_012345_AdBanner

Device.X_EXAMPLE-COM_MyConfig.Status</code></pre>
<p>When appropriate, a vendor MAY also extend the set of values of an enumeration. If this is done, the vendor-specified values MUST be in the form “X_&lt;VENDOR&gt;_VendorSpecificValue”. The total length of such a string MUST NOT exceed 31 characters.</p>
<h1 id="normative-references">4 Normative References</h1>
<p>A list of the currently valid Broadband Forum Technical Reports is published at <a href="http://www.broadband-forum.org" class="uri">http://www.broadband-forum.org</a>. The following documents are referenced by this specification.</p>
<ol type="1">
<li><p><a href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>, <em>Key words for use in RFCs to Indicate Requirement Levels</em>, IETF, 1997</p></li>
<li><p><a href="https://www.broadband-forum.org/technical/download/TR-069_Amendment-6.pdf">TR-069 Amendment 6</a>, <em>CPE WAN Management Protocol</em>, Broadband Forum, 2018</p></li>
<li><p><a href="http://standards.ieee.org/faqs/OUI.html"><em>Organizationally Unique Identifiers (OUIs)</em></a>, IEEE</p></li>
<li><p><a href="http://www.w3.org/TR/2000/NOTE-SOAP-20000508"><em>Simple Object Access Protocol (SOAP) 1.1</em></a>, W3C, 2000</p></li>
<li><p><a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>, <em>Uniform Resource Identifier (URI): Generic Syntax</em>, IETF, 2005</p></li>
<li><p><em><a href="http://www.w3.org/TR/REC-xml">Extensible Markup Language (XML) 1.0 (Fourth Edition)</a>, W3C,</em> 2008</p></li>
<li><p><a href="http://www.ietf.org/rfc/rfc2648.txt">RFC 2648</a>, <em>A URN Namespace for IETF Documents</em>, IETF, 1999</p></li>
<li><p><em><a href="https://www.broadband-forum.org/technical/download/TR-143_Amendment-1_Corrigendum-1.pdf">TR-143 Amendment 1 Corrigendum 1</a>, Enabling Network Throughput Performance Tests and Statistical Monitoring, Broadband Forum, 2015</em></p></li>
<li><p><em><a href="http://www.w3.org/TR/xmlschema-0">XML Schema Part 0: Primer Second Edition</a>, W3C,</em> 2004</p></li>
<li><p><a href="http://www.broadband-forum.org/technical/download/TR-181_Issue-2_Amendment-12.pdf">TR-181 Issue 2 Amendment 12</a>, <em>Device Data Model for TR-069</em>, Broadband Forum, 2018</p></li>
<li><p><em><a href="http://www.w3.org/TR/xmlschema-2">XML Schema Part 2: Datatypes Second Edition</a>, W3C,</em> 2004</p></li>
<li><p><a href="https://www.broadband-forum.org/technical/download/TR-140_Amendment-3.pdf"><em>TR-140 Amendment 3</em></a>, TR-069 Data Model for Storage Service Enabled Devices, Broadband Forum, 2017</p></li>
<li><p><a href="https://www.broadband-forum.org/technical/download/TR-369.pdf"><em>TR-369</em></a>, User Services Platform, Broadband Forum, 2018</p></li>
</ol>
<!-- -->
<h1 id="annex-a.-cwmp-data-model-definition-xml-schema">Annex A. CWMP Data Model Definition XML Schema</h1>
<h2 id="a.1-introduction">A.1 Introduction</h2>
<p>The CWMP Data Model Definition XML Schema 9, or DM Schema, is used for defining CWMP 2 and USP 13 data models, and is specified in A.2.12.6.</p>
<p>DM Schema instance documents can contain any or all of the following:</p>
<ul>
<li><p>Data type definitions</p></li>
<li><p>Root Object definitions (including profiles)</p></li>
<li><p>Service Object definitions (including profiles)</p></li>
<li><p>Component definitions</p></li>
<li><p>Vendor extension definitions</p></li>
</ul>
<p>Annex C contains some additional normative requirements that apply only to BBF standard DM Schema instance documents.</p>
<p>Most of the data model elements are common to CWMP and USP. Those that are specific to either protocol will be noted in the description.</p>
<h3 id="a.1.1-character-encoding-and-character-set">A.1.1 Character Encoding and Character Set</h3>
<p>BBF standard DM Schema instance documents use UTF-8 encoding and their character set is restricted to printable ASCII characters. See C.2 for the corresponding normative requirements.</p>
<h2 id="a.2-normative-information">A.2 Normative Information</h2>
<p>It is possible to create instance documents that conform to the DM Schema but nevertheless are not valid data model definitions. This is because it is not possible to specify all the normative data model definition requirements using the XML Schema language. Therefore, the schema contains additional requirements written using the usual normative language. Instance documents that conform to the DM Schema and meet these additional requirements are referred to as DM Instances.</p>
<p>For example, the definition of the parameter element includes the following additional requirements on the name and base attributes:</p>
<pre><code>&lt;xs:complexType name=&quot;ModelParameter&quot;&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
    Parameter definition and
    reference.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;

  ...

  &lt;xs:attribute name=&quot;name&quot; type=&quot;tns:ParameterName&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
      MUST be unique within the parent object
      (this is checked by schema validation).

      MUST be present if and only if defining a new
      parameter.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:attribute&gt;

  &lt;xs:attribute name=&quot;base&quot; type=&quot;tns:ParameterName&quot;&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        MUST be present if and only if modifying an existing
        parameter.
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
  &lt;/xs:attribute&gt;

  ...

&lt;/xs:complexType&gt;</code></pre>
<p>In some cases, a requirement that is in fact implied by the DM Schema is emphasized within the schema via the xs:documentation element (the uniqueness requirement on the name is an example of this).</p>
<p>In other cases, a schema-implied requirement is not highlighted. For example, the name and base attributes are of type tns:ParameterName:</p>
<pre><code>    &lt;!DOCTYPE cwmp-datamodel [
      …
      &lt;!ENTITY name &quot;([\i-[:]][\c-[:\.]]*)&quot;&gt;
      …
    ]&gt;
      …
      &lt;xs:simpleType name=&quot;ParameterName&quot;&gt;
        &lt;xs:annotation&gt;
          &lt;xs:documentation&gt;Parameter name (maximum length 256); the same as xs:NCName except that periods are not permitted.  This name MUST in addition follow the vendor-specific parameter name requirements of Section 3.3.&lt;/xs:documentation&gt;
        &lt;/xs:annotation&gt;
        &lt;xs:restriction base=&quot;xs:token&quot;&gt;
          &lt;xs:maxLength value=&quot;256&quot;/&gt;
          &lt;xs:pattern value=&quot;&amp;name;&quot;/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;</code></pre>
<p>This states that the parameter name is a string that follows the following rules:</p>
<ul>
<li><p>It is derived from xs:token, which has a whitespace facet of “collapse”, meaning that any leading whitespace in the name will be ignored.</p></li>
<li><p>It has a maximum length of 256 characters.</p></li>
<li><p>Its first character matches the pattern “<code>[\i-:]]</code>”, which means “any character permitted as the first character of an XML name, except for a colon”, and any subsequent characters match the pattern “<code>[\c-[:\.]]</code>”, which means “any character permitted in an XML name, except for a colon and a dot”.</p></li>
<li><p>It follows the vendor-specific parameter name requirements of Section 3.3.</p></li>
</ul>
<p>The question of the location of the definitive normative information therefore arises. The answer is as follows:</p>
<ul>
<li><p>All the normative information in the main part of the document remains normative.</p></li>
<li><p>The DM Schema, and the additional requirements therein, are normative. Some of these additional requirements are duplicated (for emphasis) in this Annex.</p></li>
<li><p>The DM Schema references additional material in this Annex. Such material is normative.</p></li>
<li><p>If the DM Schema conflicts with a normative requirement in the main part of the document, this is an error in the DM Schema, and the requirement in the main part of the document takes precedence.</p></li>
</ul>
<h3 id="a.2.1-importing-dm-instances">A.2.1 Importing DM Instances</h3>
<p>DM Instances are imported using the top-level import element. The DM Schema specifies that the DM Instance is located via the file attribute.</p>
<p>The rules governing the file attribute’s value and its use for locating the DM Instance are as follows:</p>
<ul>
<li><p>It MUST be a URL adhering to RFC 3986 5.</p></li>
<li><p>If the URL includes a scheme, it MUST be http, https or ftp.</p></li>
<li><p>If the URL includes an authority, it MUST NOT include credentials.</p></li>
<li><p>For standard BBF DM Instances, the rules that apply to the filename part (final path segment) of the A.2.1.1 BBFURL also apply to the filename part of this URL. This means that the corrigendum number can be omitted in order to refer to the latest corrigendum. See C.3.6 for the corresponding normative requirement.</p></li>
<li><p>If the URL is a relative reference, processing tools MUST apply their own logic, e.g. apply a search path.</p></li>
</ul>
<h4 id="a.2.1.1-uri-conventions">A.2.1.1 URI Conventions</h4>
<p>The top-level spec attribute contains the URI of the associated specification document, e.g. the BBF Technical Report.</p>
<p>This URI SHOULD uniquely identify the specification. More than one DM Schema instance document MAY reference the same specification.</p>
<p>The top-level file attribute contains the name of the DM Schema instance document, e.g. the XML file that defines a given version of a data model.</p>
<p>The following rules apply to the value of the top-level spec attribute:</p>
<ul>
<li><p>For a BBF Technical Report, it will be of the form “<code>urn:broadband-forum-org:tr-nnn-i-a-c</code>”, where nnn is the specification number (including leading zeros), i is the issue number, a is the amendment number, and c is the corrigendum number. The issue, amendment and corrigendum numbers do not include leading zeros. For example, “<code>urn:broadband-forum-org:tr-106-1-0</code>” refers to TR-106 (Issue 1 Amendment 0), and “<code>urn:broadband-forum-org:tr-106-1-2</code>” refers to TR-106 (Issue 1) Amendment 2. See C.3.4 for the corresponding normative requirement.</p></li>
<li><p>For specifications issued by other standards organizations, or by vendors, it SHOULD be of a standard form if one is defined. For example, RFC 2648 7 specifies a syntax for referencing RFCs.</p></li>
<li><p>Note that processing tools are likely to assume that all files that share a spec value are related to each other. Therefore, use of meaningful spec values is RECOMMENDED.</p></li>
</ul>
<p>The following rules apply to the value of the top-level file attribute.</p>
<ul>
<li><p>For a BBF Technical Report, it will be of the form “<code>tr-nnn-i-a-c.xml</code>” or “<code>tr-nnn-i-a-c-label.xml</code>”, where nnn, i, a and c are the same as in the spec attribute. The label, which MUST NOT begin with a digit, is not needed if only one DM Schema instance document is associated with the specification. See C.3.5 for the corresponding normative requirement.</p></li>
<li><p>It SHOULD be the same as the actual file name (omitting the directory name). Under some circumstances this will not be possible, e.g. because the content is stored in a database and not in a file system.</p></li>
</ul>
<p>Formally, the values of the spec and file attributes are defined as follows:</p>
<pre><code>SpecAttr = SpecURI

FileAttr = FileName

SpecURI = BBFURI
        | OtherURI

BBFURI = &quot;urn:broadband-forum-org:&quot; BBFDoc

FileName = BBFDoc BBFSubDoc &quot;.xml&quot;

BBFDoc = &quot;tr-&quot; BBFNumber BBFIssue BBFAmendment BBFCorrigendum

BBFNumber = [DIGIT]{3,}     // including leading zeros, e.g. 069

BBFIssue = &quot;-&quot; NoLeadingZeroPositiveNumber

BBFAmendment = &quot;-&quot; NoLeadingZeroNumber

BBFCorrigendum = &quot;-&quot; NoLeadingZeroNumber

BBFSubDoc = &quot;-&quot; LABEL       // distinguishing label (not beginning with a digit)
          | &quot;&quot;              // not needed if only one DM Instance is associated with spec

NoLeadingZeroNumber = [DIGIT]
                    | [NONZERODIGIT] [DIGIT]*

NoLeadingZeroPositiveNumber = [NONZERODIGIT] [DIGIT]*

OtherURI = &lt;of a standard form if one is defined&gt;</code></pre>
<p>Standard BBF DM Instances can be accessed at the following URL:</p>
<pre><code>BBFURL = &quot;http://www.broadband-forum.org/cwmp/&quot; FileName

FileName = &lt;as before, except that BBFCorrigendum is modified as follows:&gt;

BBFCorrigendum = &quot;-&quot; NoLeadingZeroNumber
               | &quot;&quot;         // if omitted, most recent corrigendum is assumed</code></pre>
<p>For example, the DM Instance associated with TR-181 Issue 2 Amendment 12 can be accessed at <a href="https://www.broadband-forum.org/cwmp/tr-181-2-12-0.xml" class="uri">https://www.broadband-forum.org/cwmp/tr-181-2-12-0.xml</a>.</p>
<h3 id="a.2.2-descriptions">A.2.2 Descriptions</h3>
<p>Many elements have descriptions, and the same rules apply to all description elements in the DM Schema. A description is free text which can contain a limited amount of MediaWiki-like markup as specified in A.2.2.3.</p>
<h4 id="a.2.2.1-character-set">A.2.2.1 Character Set</h4>
<p>Character set requirements apply to the entire DM Instance, so the contents of this section have been moved to C.2, which contains the normative requirements that apply to standard BBF DM Instances.</p>
<h4 id="a.2.2.2-pre-processing">A.2.2.2 Pre-processing</h4>
<p>All DM Instance processing tools MUST conceptually perform the following pre-processing before interpreting the markup:</p>
<ol type="1">
<li><p>Remove any leading whitespace up to and including the first line break. <em>Note: It can be assumed that all line breaks are represented by a single line feed, i.e. ASCII 10. See C.2.</em></p></li>
<li><p>Remove the longest common whitespace prefix (i.e. that occurs at the start of every line) from each line. See the example below, where three lines start with four spaces and one line starts with five spaces, so the longest whitespace prefix that occurs at start of each line is four spaces. In this calculation, a tab character counts as a single character. To avoid confusion, the description SHOULD NOT contain tab characters.</p></li>
<li><p>Remove all trailing whitespace, including line breaks.</p></li>
</ol>
<p>This pre-processing is designed to permit a reasonable variety of layout styles while still retaining predictable behavior. For example, both the following:</p>
<pre><code>&lt;description&gt;This is the first line.
This is the second line.
 This is the indented third line.
This is the fourth line.&lt;/description&gt;</code></pre>
<p>And:</p>
<pre><code>&lt;description&gt;
    This is the first line.
    This is the second line.
     This is the indented third line.
    This is the fourth line.
&lt;/description&gt;</code></pre>
<p>…result in the following:</p>
<pre><code>This is the first line.
This is the second line.
  This is the indented third line.
This is the fourth line.</code></pre>
<h4 id="a.2.2.3-markup">A.2.2.3 Markup</h4>
<p>The pre-processed description can contain the following markup, which is inspired by, but is not identical to, MediaWiki markup. All DM Instance processing tools SHOULD support this markup to the best of their ability.</p>
<p>Table 1 - XML Desccription Markup</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 25%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Markup Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Italics</td>
<td><code>’’italic text’’</code></td>
<td>Two apostrophes on each side of some text will result in the contained text being emphasized in italics.</td>
</tr>
<tr class="even">
<td>Bold</td>
<td><code>’’’bold text’’’</code></td>
<td>Three apostrophes on each side of some text will result in the contained text being emphasized in bold.</td>
</tr>
<tr class="odd">
<td>Bold italics</td>
<td><code>’’’’’b+i text’’’’’</code></td>
<td>Five apostrophes on each side of some text will result in the contained text being emphasized in bold italics.</td>
</tr>
<tr class="even">
<td>Paragraph</td>
<td>This paragraph just ended.</td>
<td>A line break is interpreted as a paragraph break.</td>
</tr>
<tr class="odd">
<td>Bulleted lists</td>
<td><code>* level one</code> <br> <code>** level two</code> <br> <code>* level one again</code> <br> <code>** level two again</code> <br> <code>*** level three</code> <br> <code>*: level one continued</code> <br> <code>outside of list</code></td>
<td>A line starting with one or more asterisks (*) denotes a bulleted list entry, whose indent depth is proportional to the number of asterisks specified. If the asterisks are followed by a colon (:), the previous item at that level is continued, as shown. An empty line, or a line that starts with a character other than an asterisk, indicates the end of the list.</td>
</tr>
<tr class="even">
<td>Numbered lists</td>
<td><code># level one</code> <br> <code>## level two</code> <br> <code># level one again</code> <br> <code>## level two again</code> <br> <code>### level three</code> <br> <code>#: level one continued</code> <br> <code>outside of list</code></td>
<td>A line starting with one or more number signs (#) denotes a numbered list entry. All other conventions defined for bulleted lists apply here (using # rather than *), except that numbered list entries are prefixed with an integer decoration rather than a bullet.</td>
</tr>
<tr class="odd">
<td>Indented lists</td>
<td><code>: level one</code> <br> <code>:: level two</code> <br> <code>: level one again</code> <br> <code>:: level two again</code> <br> <code>::: level three</code> <br> <code>outside of list</code></td>
<td>A line starting with one or more colons (:) denotes an indented list entry. All other conventions defined for bulleted lists apply here (using : rather than *), except that indented list entries have no prefix decoration, and item continuation is not needed.</td>
</tr>
<tr class="even">
<td>Verbatim</td>
<td>code example: <br> <code>if (something)</code> <br> <code>{</code> <br> <code>/* do something */</code> <br> <code>} else {</code> <br> <code>/* do other */</code> <br> <code>}</code></td>
<td>A block of lines each of which starts with a space is to be formatted exactly as typed, preferably in a fixed width font. This allows code fragments, simple tables etc. to be included in descriptions. Note that the pre-processing rules of A.2.2.2 imply that it is not possible to process an entire description as verbatim text (because all the leading whitespace would be removed). This is not expected to be a problem in practice.</td>
</tr>
<tr class="odd">
<td>Hyperlinks</td>
<td><code>http://www.broadband-forum.org</code></td>
<td>URL links are specified as plain old text (no special markup).</td>
</tr>
<tr class="even">
<td>Templates</td>
<td>{{bibref|1|section 2}} <br> {{section|table}} <br> {{param|Enable}} <br> {{enum|Error}}</td>
<td>Text enclosed in double curly braces ({}) is a template reference, which is replaced by template-dependent text. A.2.2.4 specifies the standard templates.</td>
</tr>
</tbody>
</table>
<h4 id="a.2.2.4-templates">A.2.2.4 Templates</h4>
<p>A template invocation is encoded as two curly braces on either side of the template name and arguments. Arguments can follow the template name, separated by vertical pipe (<code>|</code>) characters. All whitespace is significant. For example:</p>
<p><code>{{someTemplate|arg1|arg2|...|argN}}</code></p>
<p>In some cases, one template can impact the behavior of another template, e.g. the definitions of both the <code>{{enum}}</code> and the <code>{{hidden}}</code> templates state that the template expansion can be automatically placed after the rest of the description, which raises the question of which template expansion would come first. This ambiguity is resolved by stating that processing tools SHOULD generate such automatic text in the same order that the templates are defined below. In the above example, <code>{{enum}}</code> is defined before <code>{{hidden}}</code>, so an auto­mat­ically-generated list of enumeration values would be placed before an automatically-generated explanation that the parameter value is hidden.</p>
<p>The following standard templates are defined. Any vendor-specific template names MUST obey the rules of Section 3.3.</p>
<p>Table 2 – XML Description Templates</p>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 6%" />
<col style="width: 90%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Markup Definition</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Glossary reference</td>
<td>{{gloref|id}}</td>
<td>Glossary reference. The id argument MUST match the id attribute of one of the current file’s (or an imported file’s) top-level glossary element’s item elements (A.2.4.1). Typically, processing tools will (a) validate the id, and (b) replace the template reference with something like “id”. Markup examples: {{gloref|Parameter}}</td>
</tr>
<tr class="even">
<td>Abbreviation reference</td>
<td>{{abbref|id}}</td>
<td>Abbreviation reference. The id argument MUST match the id attribute of one of the current file’s (or an imported file’s) top-level abbreviations element’s item elements (A.2.4.2). Typically, processing tools will (a) validate the id, and (b) replace the template reference with something like “id”. Markup examples: {{abbref|CWMP}}</td>
</tr>
<tr class="odd">
<td>Approval date</td>
<td>{{appdate|date}}</td>
<td>The date on which this file was approved. The date argument SHOULD be of the form “day month year” where “day” is the OPTIONAL day number (no leading zero) “month” is the full (capitalized) month name, and “year” is the year (including century). Markup example: {{appdate|5 November 2011}} {{appdate|November 2012}}</td>
</tr>
<tr class="even">
<td>Document name</td>
<td>{{docname|name}}</td>
<td>The DM Instance name or title. The name argument MUST distinguish this file from other different files but not from other versions of the same file or data model. Markup example: {{docname|Device Data Model for TR-069}}</td>
</tr>
<tr class="odd">
<td>TR name</td>
<td>{{trname|name}}</td>
<td>The name and version of the corresponding Word / PDF document. The name argument MUST identify the Word / PDF document corresponding to this DM Instance, and be of the form “TR-nnnixaycz” as defined in A.2.4.3. Markup example: {{trname|TR-181i2a5}}</td>
</tr>
<tr class="even">
<td>XML reference</td>
<td>{{xmlref|ref}} {{xmlref|ref|label}}</td>
<td>A reference to this or another DM Instance. The ref argument MUST identify a DM Instance and be the filename part of the referenced DM Instance (a) optionally omitting the corrigendum number, and (b) omitting the trailing “.xml”. The OPTIONAL label argument MAY be used by processing tools as a user-visible label; if it is omitted, processing tools will derive the label from the value of the ref argument. Typically, processing tools will (a) validate the reference, and (b) replace the template reference with the label, possibly rendered in a distinctive font, and (if referencing a different file) a hyperlink. Markup examples: {{xmlref|tr-181-2-5}} {{xmlref|tr-196-2-0-1|Corrigendum 1}}</td>
</tr>
<tr class="odd">
<td>Bibliographic reference</td>
<td>{{bibref|id}} {{bibref|id|section}}</td>
<td>A bibliographic reference. The id argument MUST match the id attribute of one of the current file’s (or an imported file’s) top-level bibliography element’s reference elements (A.2.4.3). The OPTIONAL section argument specifies the section number, including any leading “section”, “annex” or “appendix” text. Typically, processing tools will (a) validate the id, and (b) replace the template reference with something like “[id]] section”. Markup examples: {{bibref|RFC3986}} {{bibref|RFC3986|Section 3}}</td>
</tr>
<tr class="even">
<td>Section separator</td>
<td>{{section|category}} {{section}}</td>
<td>The beginning or end of a section or category. This is a way of splitting the description into sections. If the category argument is present, this marks the end of the previous section (if any), and the beginning of a section of the specified category. The “table”, “row” and “examples” categories are reserved for the obvious purposes. If the category argument is absent, this marks the end of the previous section (if any). Typically, processing tools will (a) validate the category, and (b) replace the template reference with a section marker. Markup examples: {{section|table}} {{section|row}} {{section|examples}}</td>
</tr>
<tr class="odd">
<td>Number of entries parameter description</td>
<td>{{numentries}}</td>
<td>A description of a “NumberOfEntries” parameter. This template SHOULD be used for all such parameters. It will be expanded to something like “The number of entries in the &lt;table&gt; table.”. In most cases, the description will consist only of {{numentries}} but it MAY be followed by additional text if desired.</td>
</tr>
<tr class="even">
<td>Parameter and object reference</td>
<td>{{param|ref}} {{param|ref|scope}} {{param}} {{object|ref}} {{object|ref|scope}} {{object}}</td>
<td>A reference to the specified parameter or object. The OPTIONAL ref and scope arguments reference a parameter or object. Scope defaults to normal. Parameter and object names SHOULD adhere to the rules of A.2.3.4. Typically, processing tools will (a) validate the reference, and (b) replace the template reference with the ref argument or, if it is omitted, the current parameter or object name, possibly rendered in a distinctive font. Processing tools can use the scope to convert a relative path into an absolute path in order, for example, to generate a hyperlink. Markup examples: {{param|Enable}} {{object|Stats.}}</td>
</tr>
<tr class="odd">
<td>Profile reference</td>
<td>{{profile|ref}} {{profile}}</td>
<td>A reference to the specified profile. The OPTIONAL ref argument references a profile. Typically, processing tools will (a) validate the reference, and (b) replace the template reference with the ref argument or, if it is omitted, the current profile name, possibly rendered in a distinctive font. Markup examples: {{profile|Baseline:1}} {{profile}}</td>
</tr>
<tr class="even">
<td>List description</td>
<td>{{list}} {{list|arg}} {{nolist}}</td>
<td>A description of the current parameter’s list attributes. This template SHOULD only be used within the description of a list-valued parameter (A.2.7.1). This is a hint to processing tools to replace the template reference with a description of the parameter’s list attributes. This overrides processing tools’ expected default behavior (unless suppressed by {{nolist}}) of describing the list attributes before the rest of the description. The OPTIONAL argument specifies a fragment of text that describes the list and SHOULD be incorporated into the template expansion. Typically processing tools will generate text of the form “Comma-separated list of &lt;dataType&gt;.” Or “Comma-separated list of &lt;dataType&gt;, &lt;arg&gt;.”.</td>
</tr>
<tr class="odd">
<td>Reference description</td>
<td>{{reference}} {{reference|arg}} {{reference|arg|opts}} {{noreference}}</td>
<td>A description of the object or parameter that is referenced by the current parameter. This template SHOULD only be used within the description of a reference parameter (A.2.3.7). This is a hint to processing tools to replace the template reference with a description of the parameter’s reference attributes. This overrides processing tools’ expected default behavior (unless suppressed by {{noref­er­en­ce}}) of describing the reference attributes after the list attributes (for a list-valued parameter) or before the rest of the description (otherwise). The OPTIONAL arg argument is relevant only for a pathRef; it specifies a fragment of text that describes the referenced item and SHOULD be incorporated into the template expansion. The OPTIONAL opts argument is a comma-separated list of keywords that give additional information about the reference and can affect the generated text. The following keywords are currently defined: <br><br>- ignore: ignore any non-existent targetParents; this is useful when a parameter references different objects in different data models.<br>- delete: this object (the referencing object) and the referenced object have the same lifetime, so this object will always be deleted when the referenced object is deleted; therefore the reference can never be null.<br><br> Typically processing tools will generate text of the form “The value MUST be the full path name of &lt;arg&gt;…”, in which the generated text can be expected to be sensitive to whether or not the parameter is list-valued. Markup examples: {{reference|a protocol object}} {{reference|all Host table entries|ignore}}</td>
</tr>
<tr class="even">
<td>Named data type</td>
<td>{{datatype}} {{datatype|arg}} {{nodatatype}}</td>
<td>A description of the current parameter’s named data type. This template SHOULD only be used within the description of a parameter of a named data type (A.2.3.1). This is a hint to processing tools to replace the template reference with an indication of the parameter’s named data type, possibly including additional details or a hyperlink to such details. This overrides processing tools’ expected default behavior (unless suppressed by {{nodatatype}}) of describing the named data type before the rest of the description. The OPTIONAL argument affects how the data type is described. If it has the literal value “expand”, processing tools SHOULD replace the template reference with the actual description of the named data type (as opposed to referencing the description of the named data type).</td>
</tr>
<tr class="odd">
<td>Profile description</td>
<td>{{profdesc}} {{noprofdesc}}</td>
<td>An auto-generated description of a profile. This template SHOULD only be used within the description of a profile (A.2.11). This is a hint to processing tools to replace the template reference with a description of the profile. This overrides processing tools’ expected default behavior (unless suppressed by {{noprofdesc}}) of describing the profile before the rest of the description. Typically processing tools will generate text of the form “This table defines the &lt;profile:v&gt; profile for the &lt;object:m&gt; object. The minimum REQUIRED version for this profile is &lt;object:m.n&gt;.” (or more complex text if the profile is based on or extends other profiles).</td>
</tr>
<tr class="even">
<td>Enumeration reference</td>
<td>{{enum|value}} {{enum|value|param}} {{enum|value|param|scope}} {{enum}} {{noenum}}</td>
<td>A reference to the specified enumeration value. The OPTIONAL value argument specifies one of the enumeration values for the referenced parameter. If present, it MUST be a valid enumeration value for that parameter. The OPTIONAL param and scope arguments identify the referenced parameter. Scope defaults to normal. If present, param SHOULD adhere to the rules of A.2.3.4. If omitted, the current parameter is assumed. If the arguments are omitted, this is a hint to processing tools to replace the template reference with a list of the parameter’s enumerations, possibly preceded by text such as “Enumeration of:”. This overrides processing tools’ expected default behavior (unless suppressed by {{noenum}}) of listing the parameter’s enumerations after the rest of the description. Otherwise, typically processing tools will (a) validate that the enumeration value is valid, and (b) replace the template reference with the value and/or param arguments, appropriately formatted and with the value possibly rendered in a distinctive font. Processing tools can use the scope to convert a relative path into an absolute path in order, for example, to generate a hyperlink. Markup examples: {{enum|None}} {{enum|None|OtherParam}}</td>
</tr>
<tr class="odd">
<td>Pattern reference</td>
<td>{{pattern|value}} {{pattern|value|param}} {{pattern|value|param|scope}} {{pattern}} {{nopattern}}</td>
<td>A reference to the specified pattern value. The OPTIONAL value argument specifies one of the pattern values for the referenced parameter. If present, it MUST be a valid pattern value for that parameter. The OPTIONAL param and scope arguments identify the referenced parameter. Scope defaults to normal. If present, param SHOULD adhere to the rules of A.2.3.4. If omitted, the current parameter is assumed. If the arguments are omitted, this is a hint to processing tools to replace the template reference with a list of the parameter’s patterns, possibly preceded by text such as “Possible patterns:”. This overrides processing tools’ expected default behavior (unless suppressed by {{nopattern}}) of listing the parameter’s patterns after the rest of the description. Otherwise, typically processing tools will (a) validate that the pattern value is valid, and (b) replace the template reference with the value and/or param arguments, appropriately formatted and with the value possibly rendered in a distinctive font. Processing tools can use the scope to convert a relative path into an absolute path in order, for example, to generate a hyperlink. Markup examples: {{pattern|None}} {{pattern|None|OtherParam}}</td>
</tr>
<tr class="even">
<td>Hidden value</td>
<td>{{hidden}} {{hidden|value}} {{nohidden}}</td>
<td>Text explaining that the value of the current parameter is hidden and cannot be read. This template SHOULD only be used within the description of a hidden parameter (A.2.7.1). This is a hint to processing tools to replace the template reference with text explaining that the value of the current parameter is hidden and cannot be read. This overrides processing tools’ expected default behavior (unless suppressed by {{nohidden}}) of placing this text after the rest of the description. The OPTIONAL argument indicates the value that is returned when the current parameter is read. If omitted this defaults to the expansion of the {{null}} template. Typically, processing tools will generate text of the form “When read, this parameter returns <arg>, regardless of the actual value.”.</td>
</tr>
<tr class="odd">
<td>Command parameter</td>
<td>{{command}} {{nocommand}}</td>
<td>Text explaining that the current parameter is a command parameter that triggers an Agent action. This template SHOULD only be used within the description of such a command parameter (A.2.7.1). This is a hint to processing tools to replace the template reference with text explaining that the current parameter is a command parameter that always reads back as {{null}}. This overrides processing tools’ expected default behavior (unless suppressed by {{nocommand}}) of placing this text after the rest of the description. Typically, processing tools will generate text of the form “The value is not part of the device configuration and is always {{null}} when read.”.</td>
</tr>
<tr class="even">
<td>Factory default value</td>
<td>{{factory}} {{nofactory}}</td>
<td>Text listing the factory default for the current parameter. This template SHOULD only be used within the description of a parameter that has a factory default value. This is a hint to processing tools to replace the template reference with text listing the factory default value. This overrides processing tools’ expected default behavior (unless suppressed by {{nofactory}}) of placing this text after the rest of the description. Typically, processing tools will generate text of the form “The factory default value MUST be &lt;value&gt;.”.</td>
</tr>
<tr class="odd">
<td>Unique keys description</td>
<td>{{keys}} {{nokeys}}</td>
<td>A description of the current object’s unique keys. This template SHOULD only be used within the description of a Multi-Instance Object (table) that defines one or more unique keys (A.2.10.1). This is a hint to processing tools to replace the template reference with a description of the object’s unique keys. This overrides processing tools’ expected default behavior (unless suppressed by {{nokeys}}) of describing the unique keys after the description.</td>
</tr>
<tr class="even">
<td>Units reference</td>
<td>{{units}}</td>
<td>The parameter’s units string. Typically, processing tools will (a) check that the parameter has a units string, and (b) substitute the value of its units string.</td>
</tr>
<tr class="odd">
<td>Boolean values</td>
<td>{{false}} {{true}}</td>
<td>Boolean values. Typically, processing tools will substitute the value False or True, possibly rendered in a distinctive font.</td>
</tr>
<tr class="even">
<td>Discriminator parameter description</td>
<td>{{union}} {{nounion}}</td>
<td>Text explaining the available options and use for the sub-objects which are part of the union. This template SHOULD only be used within the description of a parameter declared as a discriminatorParameter (A.2.8.1). This is a hint to processing tools to replace the template reference with text explaining the union and possible choices of sub-objects. This overrides processing tools’ expected default behavior (unless suppressed by nounion) of placing this text after the rest of the description. Typically, processing tools will generate text of the form “This parameter defines the name of the currently active sub-object of a union, members of the union are &lt;objects&gt;” but it MAY be followed by additional text, explaining the use of the available options, if desired.</td>
</tr>
<tr class="odd">
<td>Miscellaneous</td>
<td>{{issue|descr}} {{issue|opts|descr}}</td>
<td>An open issue. If only one argument is supplied, it is descr, which describes the open issue. If two arguments are supplied, they are opts and descr. The OPTIONAL opts argument is a comma-separated list of options: · The first list item is an issue category that defaults to “XXX”. · The second list item is an issue status that defaults to an empty string. Any non-empty status implies that the issue has been resolved. Typically, processing tools will assign a unique ID, e.g. a separate counter for each category of issue, and replace the template reference with the issue category, ID, status and description, possibly rendered in a distinctive font. Markup examples: {{issue|Will be labeled XXX.}} {{issue|IPsec|Will be labeled IPsec.}} {{issue|DNS,fixed|Resolved DNS issue.}}</td>
</tr>
<tr class="even">
<td></td>
<td>{{empty}}</td>
<td>Represents an empty string. Typically, processing tools will render such values in a distinctive font, possibly using standard wording, such as <Empty> or “an empty string”.</td>
</tr>
<tr class="odd">
<td></td>
<td>{{null}}</td>
<td>Expands to the appropriate null value for the current parameter’s data type (A.2.3.5), e.g. {{empty}}, {{false}} or 0.</td>
</tr>
</tbody>
</table>
<h4 id="a.2.2.5-html-example">A.2.2.5 HTML Example</h4>
<p>This includes examples of most of the markup and templates.</p>
<pre><code>    &lt;model name=&quot;Goo:1.1&quot; base=&quot;Goo:1.0&quot;&gt;

    &lt;object name=&quot;GooTop.&quot; access=&quot;readOnly&quot; minEntries=&quot;1&quot;
    maxEntries=&quot;1&quot;&gt;

    &lt;parameter name=&quot;ExampleParam&quot; access=&quot;readOnly&quot;&gt;

    &lt;description&gt;

    {{section|Introduction}}This is an &#39;&#39;example&#39;&#39; parameter that
    illustrates many of the &#39;&#39;&#39;formatting&#39;&#39;&#39; templates. For
    &#39;&#39;&#39;&#39;&#39;example&#39;&#39;&#39;&#39;&#39;, this references {{bibref|TR-106a1|section
    3.2}}.

    {{section|Usage}}This parameter is called {{object}}{{param}}. One can
    also reference other parameters in the same object, such as
    {{param|OtherParameter}}, and indicate that the parameter value is
    measured in {{units}}.

    One can also include bulleted lists:

    * level one

    ** level two

    * level one again

    ** level two again

    *** level three

    *: level one continued

    and numbered lists:

    # level one

    ## level two

    # level one again

    ## level two again

    ### level three

    #: level one continued

    and indented lists

    : level one

    :: level two

    : level one again

    :: level two again

    ::: level three

    and hyperlinks such as http://www.google.com

    and code examples:

    if (something) {

    /* do something */

    } else {

    /* do other */

    }

    If the parameter was Boolean, one could refer to its values {{false}}
    and {{true}}.

    One can refer to its enumerations individually, e.g. {{enum|Disabled}},
    or to other parameters&#39; enumerations, such as
    {{enum|Value|OtherParam}}, or can list them all. {{enum}}

    Finally, if there were any patterns they could be listed too.
    {{pattern}}

    &lt;/description&gt;

    &lt;syntax&gt;

    &lt;string&gt;

    &lt;enumeration value=&quot;A&quot;/&gt;

    &lt;enumeration value=&quot;B&quot;/&gt;

    &lt;units value=&quot;packets&quot;/&gt;

    &lt;/string&gt;

    &lt;/syntax&gt;

    &lt;/parameter&gt;</code></pre>
<p>The resulting HTML would look something like this:</p>
<figure>
<img src="./figure-4.png" alt="html example" /><figcaption>html example</figcaption>
</figure>
<h3 id="a.2.3-data-types">A.2.3 Data Types</h3>
<p>CWMP 2 and USP 13 data models support only the primitive data types listed in the last row of Table 3 “on the wire”. However, the DM Schema allows data types to be derived from the primitive types or from other named data types. Such derived types can be named or anonymous.</p>
<h4 id="a.2.3.1-named-data-types">A.2.3.1 Named Data Types</h4>
<p>Named data types are defined using the top-level dataType element. A DM Instance can contain zero or more top-level dataType elements.</p>
<p>When defining a new named data type, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 3 – XML Named Data Types</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>The data type name.</td>
</tr>
<tr class="even">
<td>base</td>
<td>The base type name, i.e. name of the data type from which this data type is derived. This is used only where the base type is itself a named data type, not a primitive type.</td>
</tr>
<tr class="odd">
<td>status</td>
<td>The data type’s {current, deprecated, obsoleted, deleted} status. This defaults to current, and so is not likely to be specified for a new data type.</td>
</tr>
<tr class="even">
<td>description</td>
<td>The data type’s description (A.2.2).</td>
</tr>
<tr class="odd">
<td>list minItems maxItems nestedBrackets size</td>
<td>If the data type is list-valued, details of the list value. This allows specification of the maximum and minimum number of items in the list, and of nested list behavior, and also supports a size facet for the list (A.2.3.3). Note that a list-valued data type is always a string as far as the protocol is concerned. For a list, the rest of the data type specification refers to the individual list items, not to the parameter value.</td>
</tr>
<tr class="even">
<td>size pathRef instanceRef range enumeration enumerationRef pattern units default</td>
<td>Data type facets (A.2.3.3). These are permitted only when the base type is a named data type, i.e. when the base attribute is specified.</td>
</tr>
<tr class="odd">
<td>base64 boolean dateTime hexBinary int long string unsignedInt unsignedLong</td>
<td>Primitive data type definition. These are permitted only when the base type is primitive. There is an element for each primitive data type, and each element supports only the facets (A.2.3.3) that are appropriate to that data type.</td>
</tr>
</tbody>
</table>
<p>For example:</p>
<pre><code>&lt;dataType name=&quot;String255&quot;&gt;
  &lt;description&gt;String of maximum length 255.&lt;/description&gt;
  &lt;string&gt;
    &lt;size maxLength=&quot;255&quot;/&gt;
  &lt;/string&gt;
&lt;/dataType&gt;

&lt;dataType name=&quot;String127&quot; base=&quot;String255&quot;&gt;
  &lt;description&gt;String of maximum length 127.&lt;/description&gt;
  &lt;size maxLength=&quot;127&quot;/&gt;
&lt;/dataType&gt;

&lt;dataType name=&quot;String127List&quot; base=&quot;String127&quot;&gt;
  &lt;description&gt;List of up to 7 strings, each of maximum length 127. If a
  list item is itself a list, it will be &quot;protected&quot; by square
  brackets.&lt;/description&gt;
  &lt;list maxItems=&quot;7&quot; nestedBrackets=&quot;required&quot;/&gt;
&lt;/dataType&gt;</code></pre>
<h4 id="a.2.3.2-anonymous-data-types">A.2.3.2 Anonymous Data Types</h4>
<p>Anonymous data types are defined within parameter syntax elements (A.2.7.1), and can apply only to the parameters within which they are defined. For example:</p>
<pre><code>&lt;parameter name=&quot;Example1&quot; access=&quot;readOnly&quot;&gt;
  &lt;syntax&gt;
    &lt;string&gt;
      &lt;size maxLength=&quot;127&quot;/&gt;
      &lt;/string&gt;
  &lt;/syntax&gt;
&lt;/parameter&gt;

&lt;parameter name=&quot;Example2&quot; access=&quot;readOnly&quot;&gt;
  &lt;syntax&gt;
    &lt;dataType base=&quot;String255&quot;&gt;
      &lt;size maxLength=&quot;127&quot;/&gt;
    &lt;/dataType&gt;
  &lt;/syntax&gt;
&lt;/parameter&gt;</code></pre>
<p>If an anonymous data type is modified in a later version of a data model, the modified anonymous data type is regarded as being derived from the original anonymous data type. Therefore the base type restriction rules of A.2.3.8 MUST be obeyed.</p>
<h4 id="a.2.3.3-data-type-facets">A.2.3.3 Data Type Facets</h4>
<p>A facet specifies some aspect of a data type, e.g. its size, range or units.</p>
<p>Note that XML Schema 9 also associates facets with data types. The XML Schema and DM Schema concepts are the same, but the set of facets is not identical.</p>
<p>The DM Schema defines the following facets (normative requirements are specified in the schema):</p>
<p>Table 4 – XML Data Type Facets</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>size</td>
<td>Size ranges for the data type (applies to string, base64, hexBinary and their derived types). Note that the size facet always refers to the actual value, not to the base64- or hexBinary-encoded value. Prior to the definition of the DM Schema, the maximum sizes of base64 parameters referred to the base64-encoded values. Processing tools that generate reports from DM Instances SHOULD include explicit clarification of whether the size ranges refer to the actual or encoded values. Note that the size facet is also used to specify the size range for list-valued parameters, which are always strings (A.2.7.1).</td>
</tr>
<tr class="even">
<td>pathRef</td>
<td>Details of how to reference parameters and objects via their Path Names (applies to string and its derived types: A.2.3.7).</td>
</tr>
<tr class="odd">
<td>instanceRef</td>
<td>Details of how to reference object instances (table rows) via their Instance Numbers (applies to int, unsignedInt and their derived types; A.2.3.7).</td>
</tr>
<tr class="even">
<td>range</td>
<td>Value ranges for the data type (applies to numeric data types and their derived types).</td>
</tr>
<tr class="odd">
<td>enumeration</td>
<td>Enumerations for the data type (applies to string and its derived types).</td>
</tr>
<tr class="even">
<td>enumerationRef</td>
<td>Enumerations for the data type, obtained at run-time from the value of a specified parameter (applies to string and its derived types; A.2.3.7).</td>
</tr>
<tr class="odd">
<td>pattern</td>
<td>Patterns for the data type (applies to string and its derived types). Pattern value syntax is the same as for XML Schema regular expressions.</td>
</tr>
<tr class="even">
<td>units</td>
<td>Units for the data type (applies to numeric data types and their derived types).</td>
</tr>
</tbody>
</table>
<p>It is important to note that the enumeration facet does not necessarily define all the valid values for a data type. This is for the following reasons:</p>
<ul>
<li><p>As specified in Section 3.3, vendors are allowed to add additional enumeration values.</p></li>
<li><p>A future version of a data model may need to add additional enumerations values.</p></li>
</ul>
<h4 id="a.2.3.4-reference-path-names">A.2.3.4 Reference Path Names</h4>
<p>Some description templates (A.2.2.4), and all reference facets (A.2.3.7), need to specify parameter or object names. It is always possible to specify a full Path Name, but it is frequently necessary or convenient to specify a relative Path Name. For example, it might be necessary to reference another parameter in the current object. Any Instance Numbers in the parameter’s full Path Name cannot be known at data model definition time, so this can only be done using a relative Path Name.</p>
<p>The following rules apply to all Path Names that are used in data model definitions for referencing parameters or objects:</p>
<ul>
<li><p>Path Names MAY contain “{i}” placeholders, which MUST be interpreted as wild cards matching all Instance Numbers, e.g. “Device.Ethernet.Interface.{i}.” references all Ethernet.Interface instances.</p></li>
<li><p>Path Names MUST NOT contain Instance Numbers.</p></li>
</ul>
<p>A Path Name is always associated with a path name scope, which defines the point in the naming hierarchy relative to which the Path Name applies.</p>
<p>Table 5 – Path Name Scope Definition</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>normal</td>
<td>This is a hybrid scope which usually gives the desired behavior: <br>- If the path begins with a “Device” component, it is relative to the top of the naming hierarchy.<br>- If the path begins with a dot, it is relative to the Root or Service Object (c.f. scope=model).<br>- Otherwise, the path is relative to the current object (c.f. scope=object).<br><br></td>
</tr>
<tr class="even">
<td>model</td>
<td>The path is relative to the Root or Service Object.</td>
</tr>
<tr class="odd">
<td>object</td>
<td>The path is relative to the current object.</td>
</tr>
</tbody>
</table>
<p>Formally, if the path name scope is normal:</p>
<ul>
<li><p>If the path is empty, it MUST be regarded as referring to the top of the naming hierarchy.</p></li>
<li><p>Otherwise, if the path begins with a “Device” component, it MUST be regarded as a full Path Name.</p></li>
<li><p>Otherwise, if the path begins with a dot (“.”), it MUST be regarded as a path relative to the Root or Service Object. For example, in the Device Root Object “.DeviceInfo.” means “Dev­ice.­DeviceInfo.”, and in the Device.­Services.­ABC­Service.1 Service Object it means “Device.­Services.­ABC­Service.­1.­DeviceInfo.”.</p></li>
<li><p>Otherwise, it MUST be regarded as a path relative to the current object. Any leading hash characters (“#”) cause it to be relative to the parent of the current object (or the parent’s parent, and so on) as described below. For example, if the current object is “Dev­ice.­LAN.”, “IPAddress” means “Device.­LAN.­IP­Add­ress”, “Stats.” means “Device.LAN.Stats.” and “#.DeviceInfo.” means “Device.DeviceInfo” (see below for more “#” examples).</p></li>
</ul>
<p>If the path name scope is model:</p>
<ul>
<li><p>If the path is empty, it MUST be regarded as referring to the Root or Service Object.</p></li>
<li><p>Otherwise, it MUST be regarded as a path relative to the Root or Service Object. Any leading dot MUST be ignored. Leading hash characters are not permitted.</p></li>
</ul>
<p>If the path name scope is object:</p>
<ul>
<li><p>If the path is empty, it MUST be regarded as referring to the current object.</p></li>
<li><p>Otherwise, it MUST be regarded as a path relative to the current object. Any leading dot MUST be ignored. Leading hash characters are not permitted.</p></li>
</ul>
<p>As mentioned above, if the path name scope is normal, a leading hash character causes the path to be relative to the parent of the current object. Additional hash characters reference the parent’s parent, and so on, but they MUST NOT be used to reference beyond the Root or Service Object. Also, for object instances, “#.” always means the Multi-Instance Object’s (table’s) parent rather than the Multi-Instance Object (table).</p>
<p>In addition, within a component definition, items that are defined outside the component MUST NOT be referenced via relative paths. This is because components can be included anywhere within the data model tree.</p>
<p>For example, if the current object is “Device.LAN.DHCPOption.{i}.”:</p>
<ul>
<li><p>“#.” means “Device.LAN.” (the table’s parent, not the table).</p></li>
<li><p>“#.DHCPOption.” means “Device.LAN.DHCPOption.” (the table).</p></li>
<li><p>“#.Stats.” means “Device.LAN.Stats.”.</p></li>
<li><p>“#.Stats.TotalBytesSent” means “Device.LAN.Stats.TotalBytesSent”.</p></li>
</ul>
<p>The following examples would be invalid if LAN was defined within a component:</p>
<ul>
<li><p>“##.” means “Device.”.</p></li>
<li><p>“##.DeviceInfo.” means “Device.DeviceInfo.”.</p></li>
<li><p>“##.DeviceInfo.Manufacturer” means “Device.DeviceInfo.Manufacturer”.</p></li>
</ul>
<p>The final example can never be valid:</p>
<ul>
<li>“###.” is not permitted (references beyond the Root Object).</li>
</ul>
<p>Note that the term “Root or Service Object”, which is used several times above, means “if within a Service Object instance, the Service Object instance; otherwise, the Root Object”.</p>
<p>For example, the pathRef and instanceRef facets (A.2.3.7) have a target­Parent attribute which specifies the possible parent(s) of the referenced parameter or object, and a targetParentScope attribute (defaulted to normal) which specifies targetParent’s scope. If the current object is within a Service Object instance, setting targetParentScope to model forces the referenced parameter or object to be in the same Service Object instance. Similarly, setting targetParentScope to object forces the referenced parameter or object to be in the same object or in a sub-object.</p>
<h4 id="null-values-and-references">Null Values and References</h4>
<p>Each primitive data type has an associated null value that is used, for example, as the expansion of the {{null}} template (A.2.2.4). These null values are defined as follows:</p>
<ul>
<li><p><strong>base64, hexBinary, string:</strong> an empty string</p></li>
<li><p><strong>unsignedInt, unsignedLong:</strong> 0</p></li>
<li><p><strong>int, long:</strong> -1</p></li>
<li><p><strong>boolean:</strong> false</p></li>
<li><p><strong>dateTime:</strong> 0001-01-01T00:00:00Z (the Unknown Time; see Section 3.2.1)</p></li>
</ul>
<p>A null reference indicates that a reference parameter is not currently referencing anything. The value that indicates a null reference is the null value for the reference parameter’s base data type, i.e.:</p>
<ul>
<li><p><strong>string</strong>: an empty string</p></li>
<li><p><strong>unsignedInt</strong>: 0</p></li>
<li><p><strong>int</strong>: -1</p></li>
</ul>
<h4 id="a.2.3.6-reference-types">A.2.3.6 Reference Types</h4>
<p>A reference to another parameter or object can be weak or strong:</p>
<ul>
<li><p><strong>weak</strong>: it does not necessarily reference an existing parameter or object. For example, if the referenced parameter or object is deleted, the value of the reference parameter might not get updated. All weak reference parameters MUST be declared as writable.</p></li>
<li><p><strong>strong</strong>: it always either references a valid parameter or object, or else is a null reference (A.2.3.5). If the referenced parameter or object is deleted, the value of the reference parameter is always set to a null reference.</p></li>
</ul>
<p>See Section 3.2.3 for normative requirements relating to reference types and the associated Agent behavior.</p>
<h4 id="a.2.3.7-reference-facets">A.2.3.7 Reference Facets</h4>
<p>A reference facet specifies how a parameter can reference another parameter or object. There are three sorts of reference:</p>
<ul>
<li><p><strong>Path reference</strong>: references another parameter or object via its Path Name. Details are specified via the pathRef facet, which applies to string and its derived types.</p></li>
<li><p><strong>Instance reference</strong>: references an object instance (table row) via its Instance Number. Details are specified via the instanceRef facet, which applies to int, unsignedInt and their derived types.</p></li>
<li><p><strong>Enumeration reference</strong>: references a list-valued parameter via its Path Name. The current value of the referenced parameter indicates the valid enumerations for this parameter. Details are specified via the enumerationRef facet, which applies to string and its derived types.</p></li>
</ul>
<p>When defining a path reference, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 6 – PathRef Facet Definition</p>
<table>
<colgroup>
<col style="width: 1%" />
<col style="width: 98%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>targetParent</td>
<td>An XML list of Path Names that can restrict the set of parameters and objects that can be referenced. If the list is empty (the default), then anything can be referenced. Otherwise, only the immediate children of one of the specified objects can be referenced, A “{i}” placeholder in a Path Name acts as a wild card, e.g. “Device.DSL.BondingGroup.{i}.BondedChannel.{i}.Ethernet.”. Path Names cannot contain explicit Instance Identifiers.</td>
</tr>
<tr class="even">
<td>targetParentScope</td>
<td>Specifies the point in the naming hierarchy relative to which targetParent applies (A.2.3.4): normal (default), model or object.</td>
</tr>
<tr class="odd">
<td>targetType</td>
<td>Specifies what types of item can be referenced:<br>- any: any parameter or object can be referenced (default)<br>- parameter: any parameter can be referenced<br>- object: any object can be referenced<br>- single: any single-instance object can be referenced<br>- table: any Multi-Instance Object (table) can be referenced<br>- row: any Multi-Instance Object (table) instance (row) can be referenced<br><br></td>
</tr>
<tr class="even">
<td>targetDataType</td>
<td>Specifies the valid data types for the referenced parameter. Is relevant only when targetType is any or parameter. Possible values are as follows: <br>- any: a parameter of any data type can be referenced (default) <br>- base64: only a base64 parameter can be referenced <br>- boolean: only a boolean parameter can be referenced <br>- dateTime: only a dateTime parameter can be referenced <br>- hexBinary: only a hexBinary parameter can be referenced <br>- integer: only an integer (int, long, unsignedInt or unsignedLong) parameter can be referenced <br>- int: only an int parameter can be referenced <br>- long: only a long (or int) parameter can be referenced <br>- string: only a string parameter can be referenced <br>- unsignedInt: only an unsignedInt parameter can be referenced <br>- unsignedLong: only an unsignedLong (or unsignedInt) parameter can be referenced <br>- <named   data type>: only a parameter of the named data type can be referenced In addition, a parameter whose data type is derived from the specified data type can be referenced. The built-in type hierarchy (a simplified version of the XML Schema type hierarchy) is as follows:<br><br><code>any<br> base64<br> boolean<br> dateTime<br> hexBinary<br> integer<br>   long<br>     int<br>   unsignedLong<br>     unsignedInt<br> string</code><br><br> Note that any and integer are not valid parameter data types. They are included in order to support “can reference any data type” and “can reference any numeric data type”.</td>
</tr>
<tr class="odd">
<td>refType</td>
<td>Specifies the reference type (A.2.3.6): weak or strong.</td>
</tr>
</tbody>
</table>
<p>When defining an instance reference, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 7 – InstanceRef Facet Definition</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>targetParent</td>
<td>Specifies the Path Name of the Multi-Instance Object (table) of which an instance (row) is being referenced. “{i}” placeholders and explicit Instance Identifiers are not permitted in the Path Name. targetParentScope can be used to specify Path Names relative to the Root or Service Object or the current object.</td>
</tr>
<tr class="even">
<td>targetParentScope</td>
<td>Specifies the point in the naming hierarchy relative to which targetParent applies (A.2.3.4): normal (default), model or object.</td>
</tr>
<tr class="odd">
<td>refType</td>
<td>Specifies the reference type (A.2.3.6): weak or strong.</td>
</tr>
</tbody>
</table>
<p>When defining an enumeration reference, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 8 – EnumerationRef Facet Definition</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>targetParam</td>
<td>Specifies the Path Name of the list-valued parameter whose current value indicates the valid enumerations for this parameter.</td>
</tr>
<tr class="even">
<td>targetParamScope</td>
<td>Specifies the point in the naming hierarchy relative to which targetParam applies (A.2.3.4): normal (default), model or object.</td>
</tr>
<tr class="odd">
<td>nullValue</td>
<td>Specifies the parameter value that indicates that none of the values of the referenced parameter currently apply (if not specified, no such value is designated). Note that if this parameter is list-valued then nullValue is not relevant, because this condition will be indicated by an empty list.</td>
</tr>
</tbody>
</table>
<p>The following examples illustrate the various possible types of reference.</p>
<pre><code>    &lt;object name=&quot;PeriodicStatistics.SampleSet.{i}.Parameter.{i}.&quot; ...&gt;
      ...
      &lt;parameter name=&quot;Reference&quot; access=&quot;readWrite&quot;&gt;
        &lt;description&gt;Reference to the parameter that is associated with this
        object instance. This MUST be the parameter&#39;s full path name.&lt;/description&gt;
        &lt;syntax&gt;
          &lt;string&gt;
            &lt;size maxLength=&quot;256&quot;/&gt;
            &lt;pathRef targetType=&quot;parameter&quot; refType=&quot;weak&quot;/&gt;
          &lt;/string&gt;
          &lt;default type=&quot;object&quot; value=&quot;&quot;/&gt;
        &lt;/syntax&gt;
      &lt;/parameter&gt;</code></pre>
<pre><code>    &lt;object name=&quot;StorageService.{i}.StorageArray.{i}.&quot; ...&gt;
      ...
      &lt;parameter name=&quot;PhysicalMediumReference&quot; access=&quot;readWrite&quot;&gt;
        &lt;description&gt;A comma-separated list of Physical Medium references.
        Each Physical Medium referenced by this parameter MUST exist within the
        same StorageService instance. A Physical Medium MUST only be referenced
        by one Storage Array instance. Each reference can be either in the form
        of &quot;.PhysicalMedium.{i}&quot; or a fully qualified object
        name...&lt;/description&gt;
        &lt;syntax&gt;
          &lt;list&gt;
            &lt;size maxLength=&quot;1024&quot;/&gt;
          &lt;/list&gt;
          &lt;string&gt;
            &lt;pathRef targetParent=&quot;.PhysicalMedium.&quot; targetParentScope=&quot;model&quot;
            targetType=&quot;row&quot; refType=&quot;strong&quot;/&gt;
          &lt;/string&gt;
        &lt;/syntax&gt;
      &lt;/parameter&gt;</code></pre>
<pre><code>    &lt;object name=&quot;STBService.{i}.Components.FrontEnd.{i}.IP.Inbound.{i}.&quot; ...&gt;
      ...
      &lt;parameter name=&quot;StreamingControlProtocol&quot; access=&quot;readOnly&quot;&gt;
        &lt;description&gt;Network protocol currently used for controlling streaming
        of the source content, or an empty string if the content is not being
        streamed or is being streamed but is not being controlled. If non-empty,
        the string MUST be one of the .Capabilities.FrontEnd.IP.StreamingControlProtocols
        values.&lt;/description&gt;
        &lt;syntax&gt;
          &lt;string&gt;
            &lt;enumerationRef
            targetParam=&quot;.Capabilities.FrontEnd.IP.StreamingControlProtocols&quot;
            nullValue=&quot;&quot;/&gt;
          &lt;/string&gt;
        &lt;/syntax&gt;
      &lt;/parameter&gt;

      &lt;parameter name=&quot;StreamingTransportProtocol&quot; access=&quot;readOnly&quot;&gt;
        &lt;description&gt;Network protocol currently used for streaming the source
        content, or an empty string if the content is not being streamed.
        If non-empty, the string MUST be one of the
        .Capabilities.FrontEnd.IP.StreamingTransportProtocols
        values.&lt;/description&gt;
        &lt;syntax&gt;
          &lt;string&gt;
            &lt;enumerationRef
            targetParam=&quot;.Capabilities.FrontEnd.IP.StreamingTransportProtocols&quot;
            nullValue=&quot;&quot;/&gt;
          &lt;/string&gt;
        &lt;/syntax&gt;
      &lt;/parameter&gt;</code></pre>
<pre><code>    &lt;object name=&quot;Device.WiFi.AccessPoint.{i}.Security.&quot; ...&gt;
      ...
      &lt;parameter name=&quot;ModeEnabled&quot; access=&quot;readWrite&quot;&gt;
        &lt;description&gt;Indicates which security mode is enabled.&lt;/description&gt;
        &lt;syntax&gt;
          &lt;list/&gt;
          &lt;string&gt;
            &lt;enumerationRef targetParam=&quot;ModesSupported&quot;/&gt;
          &lt;/string&gt;
        &lt;/syntax&gt;
      &lt;/parameter&gt;</code></pre>
<h4 id="a.2.3.8-base-type-restriction">A.2.3.8 Base Type Restriction</h4>
<p>A new data type MUST always be a restriction of its base type, meaning that a valid value of the new data type will always be a valid value for its base type. This is the case for the examples of A.2.3.1, which involve three different data types:</p>
<ul>
<li><p>string of unlimited length</p></li>
<li><p>string of maximum length 255</p></li>
<li><p>string of maximum length 127</p></li>
</ul>
<p>Clearly a string of length 100 is valid for all three data types, but a string of length 200 is only valid for the first two data types.</p>
<p>The examples of A.2.3.1 considered only the size facet, but in general all facets that are applicable to the data type have to be considered. The base type restriction requirements for each facet are as follows:</p>
<p>Table 9 – XML Facet Inheritance Rules</p>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>Facet</th>
<th>Requirements</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>size</td>
<td>The derived data type can define sizes in any way, provided that the new sizes do not permit any values that are not valid for the base type.</td>
</tr>
<tr class="even">
<td>pathRef</td>
<td>The derived data type can modify the data type in the following ways: <br>- By “promoting” status to a “higher” value, where the lowest to highest ordering is: current, deprecated, obsoleted, deleted. For example, current can be changed to deprecated, and obsoleted can be changed to deleted, but deleted cannot be changed back to obsoleted. When promoting status, the deprecation, obsoletion and deletion rules of Section 2.4 MUST be obeyed. <br>- By changing targetParent to narrow the set of possible parent objects. <br>- By changing targetType to narrow the set of possible target types. <br>- By changing targetDataType to narrow the set of possible target data types.<br><br></td>
</tr>
<tr class="odd">
<td>instanceRef</td>
<td>The derived data type can modify the data type in the following ways: <br>- By “promoting” status to a “higher” value, as described for pathRef. <br>- By changing targetParent to narrow the set of possible parent objects.<br><br></td>
</tr>
<tr class="even">
<td>range</td>
<td>The derived data type can define ranges in any way, provided that the new ranges do not permit any values that are not valid for the base type.</td>
</tr>
<tr class="odd">
<td>enumeration</td>
<td>The derived data type can modify existing enumeration values in the following ways: <br>- By “promoting” access from readOnly to readWrite. <br>- By “promoting” status to a “higher” value, as described for pathRef. <br>- By “promoting” optional from False to True. <br>- By adding a code, if none was previously specified. <br>- By using the action attribute to prefix, extend or replace the description (see below and A.2.12.6). The derived data type can add new enumeration values.</td>
</tr>
<tr class="even">
<td>enumerationRef</td>
<td>The derived data type can modify the data type by “promoting” status to a “higher” value, as described for pathRef.</td>
</tr>
<tr class="odd">
<td>pattern</td>
<td>The derived data type can modify existing pattern values by changing access, status, optional and description exactly as for enumerations. The derived data type can add new patterns and/or replace existing patterns with new patterns, provided that the new patterns do not permit any values that are not valid for the base type. For example a single pattern “[AB]” could be replaced with “A” and “B”, but “C” could not be added.</td>
</tr>
<tr class="even">
<td>units</td>
<td>The derived data type can add units if the base type did not specify any.</td>
</tr>
</tbody>
</table>
<p>Most of the above requirements are non-normative, because it has to be possible to correct errors. For example, if the base type supports a range of [-1:4095] but the values 0 and 4095 were included in error, it would be permissible for a derived type to support ranges of [-1:-1] and [1:4094.] Processing tools SHOULD be able to detect and warn about such cases.</p>
<p>When defining a new data type, if a facet is omitted, the new data type will inherit that facet from its base type. If a facet is present, it MUST be fully specified (except that special rules apply to descriptions; see below and A.2.12.6). For example, this means that a derived type that adds additional enumeration values has also to re-declare the enumeration values of the base type.</p>
<p>For example, in the following, the derived type inherits the units facet from its parent but it does not inherit the range facet, so the PacketCounter range is [10:] and the PacketCounter2 range is [15:20].</p>
<pre><code>&lt;dataType name=&quot;PacketCounter&quot;&gt;
  &lt;unsignedLong&gt;
    &lt;range minInclusive=&quot;10&quot;/&gt;
    &lt;units value=&quot;packets&quot;/&gt;
  &lt;/unsignedLong&gt;
&lt;/dataType&gt;

&lt;dataType name=&quot;PacketCounter2&quot; base=&quot;PacketCounter&quot;&gt;
  &lt;range minInclusive=&quot;15&quot; maxInclusive=&quot;20&quot;/&gt;
&lt;/dataType&gt;</code></pre>
<p>Similarly, in the following, the enumeration values for ABCD are not A, B, C and D, but are just C and D. This is an error (because the derived type cannot remove enumeration values), and processing tools SHOULD detect and warn about such cases.</p>
<pre><code>&lt;dataType name=&quot;AB&quot;&gt;
  &lt;string&gt;
    &lt;enumeration value=&quot;A&quot;/&gt;
    &lt;enumeration value=&quot;B&quot;/&gt;
  &lt;/string&gt;
&lt;/dataType&gt;

&lt;dataType name=&quot;ABCD&quot; base=&quot;AB&quot;&gt;
  &lt;string&gt;
    &lt;enumeration value=&quot;C&quot;/&gt;
    &lt;enumeration value=&quot;D&quot;/&gt;
  &lt;/string&gt;
&lt;/dataType&gt;</code></pre>
<p>A derived data type and any of its facets that support descriptions will inherit those descriptions from the base type. Facet descriptions are inherited regardless of whether the facet is present in the derived type. For any descriptions that are explicitly specified in the derived type, the action attribute controls whether they will be prefixed, extended or replaced (A.2.12.6).</p>
<p>For example, in the following, the description of Z (which is not changed) does not have to be repeated.</p>
<pre><code>&lt;dataType name=&quot;XY&quot;&gt;
  &lt;description&gt;This is XY.&lt;/description&gt;
  &lt;string&gt;
    &lt;enumeration value=&quot;X&quot;&gt;
      &lt;description&gt;This is X.&lt;/description&gt;
    &lt;/enumeration&gt;
    &lt;enumeration value=&quot;Y&quot;&gt;
      &lt;description&gt;This is Y.&lt;/description&gt;
    &lt;/enumeration&gt;
    &lt;enumeration value=&quot;Z&quot;&gt;
      &lt;description&gt;This is Z.&lt;/description&gt;
    &lt;/enumeration&gt;
  &lt;/string&gt;
&lt;/dataType&gt;

&lt;dataType name=&quot;XY2&quot; base=&quot;XY&quot;&gt;
  &lt;description action=&quot;replace&quot;&gt;This is all about XY.&lt;/description&gt;
  &lt;enumeration value=&quot;X&quot;&gt;
    &lt;description action=&quot;append&quot;&gt;This is more about X, added at the
    end.&lt;/description&gt;
  &lt;/enumeration&gt;
  &lt;enumeration value=&quot;Y&quot;&gt;
    &lt;description action=&quot;prefix&quot;&gt;This is more about Y, inserted at the
    beginning.&lt;/description&gt;
  &lt;/enumeration&gt;
  &lt;enumeration value=&quot;Z&quot;/&gt;
&lt;/dataType&gt;</code></pre>
<h2 id="glossary-abbreviations-and-bibliography">2.4 Glossary, Abbreviations and Bibliography</h2>
<h3 id="glossary">2.4.1 Glossary</h3>
<p>The glossary is defined using the top-level glossary element, which can contain zero or more item elements.</p>
<p>When defining a new glossary item, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 10 - XML Glossary Items</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">id</td>
<td style="text-align: left;">The glossary item ID. This is the term that is being defined.</td>
</tr>
<tr class="even">
<td style="text-align: left;">description</td>
<td style="text-align: left;">The description of the glossary item. This can include appropriate markup and template references, e.g. it can include {{bibref}} and {{gloref}} template references.</td>
</tr>
</tbody>
</table>
<h3 id="abbreviations">2.4.2 Abbreviations</h3>
<p>Abbreviations are defined using the top-level abbreviations element, which can contain zero or more item elements.</p>
<p>When defining a new abbreviation, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 11 - XML Abbreviation Items</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">id</td>
<td style="text-align: left;">The abbreviation item ID. This is the abbreviation that is being defined.</td>
</tr>
<tr class="even">
<td style="text-align: left;">description</td>
<td style="text-align: left;">The description of the abbreviation. This can include appropriate markup and template references, e.g. it can include {{bibref}} and {{gloref}} template references.</td>
</tr>
</tbody>
</table>
<h3 id="bibliography">2.4.3 Bibliography</h3>
<p>The bibliography is defined using the top-level bibliography element, which can contain zero or more (bibliographic) reference elements.</p>
<p>When defining a new bibliographic reference, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 12 – XML Bibliographic References</p>
<table>
<colgroup>
<col style="width: 18%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>id</td>
<td>The bibliographic reference ID.</td>
</tr>
<tr class="even">
<td>name</td>
<td>The name by which the referenced document is usually known.</td>
</tr>
<tr class="odd">
<td>title</td>
<td>The document title.</td>
</tr>
<tr class="even">
<td>organization</td>
<td>The organization that published the referenced document, e.g. BBF, IEEE, IETF.</td>
</tr>
<tr class="odd">
<td>category</td>
<td>The document category, e.g. TR (BBF), RFC (IETF).</td>
</tr>
<tr class="even">
<td>date</td>
<td>The publication date.</td>
</tr>
<tr class="odd">
<td>hyperlink</td>
<td>Hyperlink(s) to the document.</td>
</tr>
</tbody>
</table>
<p>For BBF standard DM Instances, the C.3.7 rules apply.</p>
<p>Processing tools SHOULD be lenient when comparing bibliographic reference IDs. Specifically, they SHOULD ignore all whitespace, punctuation, leading zeros in numbers, and upper / lower case. So, for example, “rfc 1234” and “RFC1234” would be regarded as the same ID, as would “TR-069” and “TR69”.</p>
<p>Processing tools SHOULD detect and report inconsistent bibliographic references, e.g. a reference with the same ID (i.e. an ID that compares as equal) as one that was encountered in a different file, but with a different name or hyperlink.</p>
<h3 id="a.2.5-components">A.2.5 Components</h3>
<p>A component is a way of defining a named set of parameters, objects and/or profiles to be used wherever such a group is needed in more than one place (or just to structure the definitions). A DM Instance can contain zero or more top-level component elements.</p>
<p>When defining a new component, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 13 – XML Component Definition</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>The component name.</td>
</tr>
<tr class="even">
<td>description</td>
<td>The component’s description (A.2.2).</td>
</tr>
<tr class="odd">
<td>component</td>
<td>The other components that are referenced (included) by this component.</td>
</tr>
<tr class="even">
<td>parameter</td>
<td>The component’s top-level parameter definitions (A.2.7).</td>
</tr>
<tr class="odd">
<td>object</td>
<td>The component’s object definitions (0).</td>
</tr>
<tr class="even">
<td>profile</td>
<td>The component’s profile definitions (A.2.11).</td>
</tr>
</tbody>
</table>
<p>Referencing (including) a component can be thought of as textual substitution. A component has no version number and is not tied to a particular Root or Service Object.</p>
<p>The following is a simple example of component definition and reference.</p>
<pre><code>&lt;component name=&quot;ByteStats&quot;&gt;
  &lt;parameter name=&quot;BytesSent&quot; access=&quot;readOnly&quot;&gt;
    &lt;description&gt;Number of bytes sent.&lt;/description&gt;
    &lt;syntax&gt;&lt;unsignedInt/&gt;&lt;/syntax&gt;
  &lt;/parameter&gt;
  &lt;parameter name=&quot;BytesReceived&quot; access=&quot;readOnly&quot;&gt;
    &lt;description&gt;Number of bytes received.&lt;/description&gt;
    &lt;syntax&gt;&lt;unsignedInt/&gt;&lt;/syntax&gt;
  &lt;/parameter&gt;
&lt;/component&gt;

&lt;model name=&quot;Device:2.11&quot;&gt;
  &lt;object name=&quot;Device.&quot; access=&quot;readOnly&quot; minEntries=&quot;1&quot;
  maxEntries=&quot;1&quot;&gt;
    ...
    &lt;component ref=&quot;ByteStats&quot;/&gt;
    ...
  &lt;/object&gt;
  ...
&lt;/model&gt;</code></pre>
<p>Here the component is referenced from within an object definition. Components can be referenced from within component, model, object, command and event definitions. Parameter, command, event, object and profile definitions within components are relative to the point of inclusion unless overridden using the path attribute.</p>
<h3 id="a.2.6-root-and-service-objects">A.2.6 Root and Service Objects</h3>
<p>Root and Service Objects are defined using the model element and an associated top-level object element. A DM Instance can contain zero or more top-level model elements.</p>
<p>When defining a new model, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 14 – XML Root and Service Objects</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>The model name, including its major and minor version numbers.</td>
</tr>
<tr class="even">
<td>base</td>
<td>The name of the previous version of the model (for use when the model version is greater than 1.0).</td>
</tr>
<tr class="odd">
<td>isService</td>
<td>Whether it is a Service Object. This defaults to False and so can be omitted for Root Objects.</td>
</tr>
<tr class="even">
<td>description</td>
<td>The model’s description (A.2.2).</td>
</tr>
<tr class="odd">
<td>component</td>
<td>The components that are referenced (included) by the model (A.2.5).</td>
</tr>
<tr class="even">
<td>parameter</td>
<td>The model’s top-level parameter definitions (A.2.7).</td>
</tr>
<tr class="odd">
<td>object</td>
<td>The model’s top-level and other object definitions (0).</td>
</tr>
<tr class="even">
<td>profile</td>
<td>The model’s profile definitions (A.2.11).</td>
</tr>
</tbody>
</table>
<p>Once a given version has been defined, it cannot be modified; instead, a new version of the object has to be defined. For example, the following example defines v1.0 and v1.1 of a notional Service Object.</p>
<pre><code>&lt;model name=&quot;DemoService:1.0&quot; isService=&quot;true&quot;&gt;
  &lt;parameter name=&quot;DemoServiceNumberOfEntries&quot; access=&quot;readOnly&quot;/&gt;
  &lt;object name=&quot;DemoService.{i}.&quot; access=&quot;readOnly&quot; minEntries=&quot;0&quot;
  maxEntries=&quot;unbounded&quot; entriesParameter=&quot;DemoServiceNumberOfEntries&quot;/&gt;
&lt;/model&gt;

&lt;model name=&quot;DemoService:1.1&quot; base=&quot;DemoService:1.0&quot;
isService=&quot;true&quot;&gt;
  &lt;object base=&quot;DemoService.{i}.&quot; access=&quot;readOnly&quot; minEntries=&quot;0&quot;
  maxEntries=&quot;unbounded&quot;/&gt;
&lt;/model&gt;</code></pre>
<h3 id="a.2.7-parameters">A.2.7 Parameters</h3>
<p>Parameters are defined using the parameter element, which can occur within component, model and object elements. When defining a new parameter, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 15 – XML Parameter Definition</p>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 92%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>The parameter name (3.1).</td>
</tr>
<tr class="even">
<td>access</td>
<td>Whether the parameter can be writable (readWrite) or not (readOnly).</td>
</tr>
<tr class="odd">
<td>status</td>
<td>The parameter’s {current, deprecated, obsoleted, deleted} status. This defaults to current, and so is not likely to be specified for a new parameter.</td>
</tr>
<tr class="even">
<td>activeNotify</td>
<td>The parameter’s {normal, forceEnabled, forceDefault, canDeny} Active Notification status. This defaults to normal, and so is not often specified for a new parameter. Note that in USP, forceEnabled and forceDefault are equivalent to normal.</td>
</tr>
<tr class="odd">
<td>forcedInform</td>
<td>For CWMP only, the parameter’s Forced Inform status. This defaults to False, and so is not often specified for a new parameter.</td>
</tr>
<tr class="even">
<td>description</td>
<td>The parameter’s description (A.2.2).</td>
</tr>
<tr class="odd">
<td>syntax</td>
<td>The parameter’s syntax (A.2.7.1).</td>
</tr>
</tbody>
</table>
<h4 id="a.2.7.1-parameter-syntax">A.2.7.1 Parameter Syntax</h4>
<p>Parameter syntax is defined using the syntax element, which can occur only within parameter elements. When defining a new parameter, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 16 – XML Parameter Syntax</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>hidden</td>
<td>Whether the value is hidden on readback. This defaults to False, and so is not often specified for a new parameter.</td>
</tr>
<tr class="even">
<td>command</td>
<td>For CWMP only, whether setting the parameter triggers an Agent action as opposed to changing the configuration. This defaults to False. Note that this is an CWMP-only attribute (not an element) and is different from the USP-only command element (A.2.8).</td>
</tr>
<tr class="odd">
<td>list minItems maxItems nestedBrackets size</td>
<td>If the parameter is list-valued, details of the list value. This allows specification of the maximum and minimum number of items in the list, and of nested list behavior, and also supports a size facet for the list (A.2.3.3). Note that a list-valued parameter is always a string as far as the protocol is concerned. For a list, the rest of the syntax specification refers to the individual list items, not to the parameter value.</td>
</tr>
<tr class="even">
<td>base64 boolean dateTime hexBinary int long string unsignedInt unsignedLong</td>
<td>If the parameter is of a primitive data type, specifies a primitive data type reference, e.g. &lt;int/&gt;. If the parameter data type is derived from a primitive data type, specifies an anonymous primitive data type definition (A.2.3.2), e.g. &lt;int&gt;&lt;range maxInclusive=“255”/&gt;&lt;/int&gt;. Each primitive data type element supports only the facets (A.2.3.3) that are appropriate to that data type.</td>
</tr>
<tr class="odd">
<td>dataType</td>
<td>If the parameter is of a named data type, specifies a named data type (A.2.3.1) reference, e.g. &lt;dataType ref=“IPAddress”/&gt;. If the parameter data type is derived from a named data type, specifies an anonymous named data type (A.2.3.2) definition, e.g. &lt;dataType base=“IPAddress”&gt;&lt;size maxLength=“15”/&gt;&lt;/dataType&gt;</td>
</tr>
</tbody>
</table>
<h3 id="a.2.8-commands-usp-only">A.2.8 Commands (USP Only)</h3>
<p>Data Model Commands are defined using the command element, which can occur within component and object elements. When defining a new Data Model Command, the following attributes and elements are relevant (normative requirements are specified in the schema). This concept does not apply to CWMP, which uses Objects and/or Parameters to simulate commands.</p>
<p>Table 17 – XML Command Definition</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 89%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>The command name (3.1).</td>
</tr>
<tr class="even">
<td>async</td>
<td>Whether this command is asynchronous or not. This defaults to false.</td>
</tr>
<tr class="odd">
<td>status</td>
<td>The command’s {current, deprecated, obsoleted, deleted} status. This defaults to current, and so is not likely to be specified for a new command.</td>
</tr>
<tr class="even">
<td>description</td>
<td>The command’s description (A.2.2).</td>
</tr>
<tr class="odd">
<td>input</td>
<td>The command’s input arguments (can be omitted if there are none).</td>
</tr>
<tr class="even">
<td>output</td>
<td>The command’s output arguments (can be omitted if there are none).</td>
</tr>
</tbody>
</table>
<p>The input / output elements define the command’s input / output arguments (respectively).</p>
<p>Table 18 – XML Command Input / Output Arguments Definition</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>component</td>
<td>The arguments defined by components that are referenced (included) by the command (A.2.5).</td>
</tr>
<tr class="even">
<td>parameter</td>
<td>The command’s parameter arguments (A.2.7).</td>
</tr>
<tr class="odd">
<td>object</td>
<td>The command’s object arguments (0).</td>
</tr>
</tbody>
</table>
<p>Command argument parameter / object elements are similar to the corresponding data model parameter / object elements but support different attributes, e.g. they have no access or numEntriesParameter attributes, and they have a Boolean mandatory attribute (to indicate a mandatory argument).</p>
<p>When a command references a component, any attributes not supported in command arguments are ignored. This allows a component that defines data model parameters / objects to be used for defining command parameter / object arguments.</p>
<p>When a command argument is a table, its instance numbers MUST be 1, 2, 3… (assigned sequentially without gaps).</p>
<h2 id="a.2.9-events-usp-only">### A.2.9 Events (USP Only)</h2>
<p>Data Model Events are defined using the event element, which can occur within component and object elements. When defining a new Data Model Event, the following attributes and elements are relevant (normative requirements are specified in the schema). This concept does not apply to CWMP.</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>The event name (3.1).</td>
</tr>
<tr class="even">
<td>status</td>
<td>The event’s {current, deprecated, obsoleted, deleted} status. This defaults to current, and so is not likely to be specified for a new event.</td>
</tr>
<tr class="odd">
<td>description</td>
<td>The event’s description (A.2.2).</td>
</tr>
<tr class="even">
<td>component</td>
<td>The arguments defined by components that are referenced (included) by the event (A.2.5).</td>
</tr>
<tr class="odd">
<td>parameter</td>
<td>The event’s parameter arguments (A.2.7).</td>
</tr>
<tr class="even">
<td>object</td>
<td>The event’s object arguments (A.2.10).</td>
</tr>
</tbody>
</table>
<p>Event argument parameter / object elements are similar to the corresponding data model parameter / object elements but support different attributes, e.g. they have no access or numEntriesParameter attributes, and they have a Boolean mandatory attribute (to indicate a mandatory argument).</p>
<p>When an event references a component, any attributes not supported in event arguments are ignored. This allows a component that defines data model parameters / objects to be used for defining event parameter / object arguments.</p>
<p>When an event argument is a table, its instance numbers MUST be 1, 2, 3… (assigned sequentially without gaps).</p>
<h3 id="a.2.10-objects">A.2.10 Objects</h3>
<p>Objects are defined using the object element, which can occur within component and model elements. When defining a new object, the following attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 19 – XML Object Definition</p>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 97%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>The object name, specified as a partial path (3.1).</td>
</tr>
<tr class="even">
<td>access</td>
<td>Whether object instances can be Added or Deleted (readWrite) or not (readOnly). Adding or deleting instances is meaningful only for a Multi-Instance Object (table).</td>
</tr>
<tr class="odd">
<td>minEntries</td>
<td>The minimum number of instances of this object (always less than or equal to maxEntries).</td>
</tr>
<tr class="even">
<td>maxEntries</td>
<td>The maximum number of instances of this object (can be “unbounded”). minEntries and maxEntries allow the object to be placed into one of three categories: · minEntries=0, maxEntries=1: single-instance object which might not be allowed to exist, e.g. because only one of it and another object can exist at the same time. Note that this is not the same thing as an optional object (in a sense, all objects are optional; requirements are specified via profiles). For an object with minEntries=0, maxEntries=1, the description MUST explain why it might not be allowed to exist, e.g. referencing the other objects that constrain it. · minEntries=1, maxEntries=1: single-instance object that is always allowed to exist. · All other cases: Multi-Instance Object (table) (A.2.10.1).</td>
</tr>
<tr class="odd">
<td>mountType</td>
<td>For USP only, denotes whether this object is a Mountable Object , a Mount Point, or none. Possible values are: · mountable: this object is a Mountable Object. Such an object appears only right under the Root Object. · mountPoint: this object is a Mount Point. · none (default): this object is neither a Mountable Object nor a Mount Point.</td>
</tr>
<tr class="even">
<td>status</td>
<td>The object’s {current, deprecated, obsoleted, deleted} status. This defaults to current, and so is not likely to be specified for a new object.</td>
</tr>
<tr class="odd">
<td>description</td>
<td>The object’s description (A.2.2).</td>
</tr>
<tr class="even">
<td>component</td>
<td>The components that are referenced (included) by the object (A.2.5).</td>
</tr>
<tr class="odd">
<td>parameter</td>
<td>The object’s parameter definitions (A.2.7).</td>
</tr>
<tr class="even">
<td>command</td>
<td>For USP only, the object’s command definitions (A.2.8).</td>
</tr>
<tr class="odd">
<td>event</td>
<td>For USP only, the object’s event definitions (A.2.9).</td>
</tr>
</tbody>
</table>
<h4 id="a.2.10.1-tables">A.2.10.1 Tables</h4>
<p>If an object is a table, several other attributes and elements are relevant (normative requirements are specified in the schema).</p>
<p>Table 20 – XML Table Definition</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>For a table, the last part of the name has to be “{i}.” (3.1).</td>
</tr>
<tr class="even">
<td>numEntriesParameter</td>
<td>The name of the parameter (in the parent object) that contains the number of entries in the table. Such a parameter is needed whenever there is a variable number of entries, i.e. whenever maxEntries is unbounded or is greater than minEntries.</td>
</tr>
<tr class="odd">
<td>enableParameter</td>
<td>For CWMP only, the name of the parameter (in each table entry) that enables and disables that table entry. Such a parameter is needed whenever access is readWrite (so the Controller might be able to create entries) and at least one uniqueKey element that defines a functional key is present.</td>
</tr>
<tr class="even">
<td>uniqueKey</td>
<td>An element that specifies a unique key by referencing those parameters that constitute the unique key (all of these parameters are single-valued, i.e. not list-valued). In CWMP only, for a non-functional key, or if the table has no enableParameter, the uniqueness requirement always applies; for a functional key, and if the table has an enableParameter, the uniqueness requirement applies only to enabled table entries.</td>
</tr>
<tr class="odd">
<td>discriminatorParameter</td>
<td>The name of the parameter (in the parent object) that selects which of the available objects that are part of the same union to use. Such a discrimination parameter is needed whenever there are multiple alternative sub-objects, i.e. objects where minEntries=0 and maxEntries=1.</td>
</tr>
</tbody>
</table>
<p>Each unique key is either functional or non-functional:</p>
<ul>
<li><p>A functional key references at least one parameter that relates to the purpose (or function) of the table, e.g. a DHCP option tag in a DHCP option table, or an external port number in a port mapping table.</p></li>
<li><p>A non-functional key references only parameters that do not relate to the purpose (or function) of the table, e.g. an Alias or Name parameter.</p></li>
</ul>
<p>A unique key is assumed to be functional unless explicitly marked as non-functional by setting the unique key’s functional attribute to false.</p>
<p>As can be seen from the description in Table 20, in CWMP, non-functional keys are always required to be unique, regardless of whether the table has an enableParameter, or is enabled or disabled. Therefore, at most one entry in a given parent object can exist with a given value for a non-functional unique key. USP doesn’t require any different behavior for both functional and non-functional keys: all keys are always required to be unique.</p>
<p>The uniqueness requirement means that the value of the unique key MUST be unique for all instances of a given parent object regardless of how instances got created.</p>
<p>If a parameter (or group of parameters) is not defined as a unique key, an Agent MUST NOT expect or require those parameters to contain a value that is unique within the table. Such parameters MAY subsequently be defined as a vendor-specific data model composite unique key, but that composite unique key definition MUST include at least one vendor-specific parameter.</p>
<h3 id="a.2.11-profiles">A.2.11 Profiles</h3>
<p>Profiles are defined using the profile element, which can occur within component and model elements. When defining a new profile, the following attributes and elements are always relevant (normative requirements are specified in the schema).</p>
<p>Table 21 – XML Profile Definition</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>name</td>
<td>The profile name, including its version number (2.3.3).</td>
</tr>
<tr class="even">
<td>base</td>
<td>The name of the previous version of the profile (for use when the profile version is greater than 1).</td>
</tr>
<tr class="odd">
<td>extends</td>
<td>A list of the names of the profiles that this profile extends.</td>
</tr>
<tr class="even">
<td>minVersion</td>
<td>A list of the model names that define the minimum versions for which this profile can be defined. Note that it is only necessary to specify this if the profile is defined within a component element.</td>
</tr>
<tr class="odd">
<td>description</td>
<td>The profile’s description (A.2.2).</td>
</tr>
<tr class="even">
<td>parameter</td>
<td>The profile’s parameter requirements, which can include descriptions, references to the parameters in question, and the parameter access requirement.</td>
</tr>
<tr class="odd">
<td>object</td>
<td>The profile’s object requirements, which can include descriptions, references to the objects in question, the object access requirements, and requirements for the object’s parameters, commands and events, including requirements for command and event arguments.</td>
</tr>
</tbody>
</table>
<p>Note:</p>
<ul>
<li><p>If a command or event specifies no argument requirements, this is the same as if all of its mandatory arguments were listed.</p></li>
<li><p>If a command or event specifies argument requirements, it has to list (at least) all its mandatory arguments.</p></li>
</ul>
<h3 id="a.2.12-modifications">A.2.12 Modifications</h3>
<p>New data types, components, models and profiles can be created based on existing items. This does not modify the existing item.</p>
<p>Parameters, commands, events, objects and profiles can be modified “in place”, i.e. without creating a new item. This still uses the parameter, command, event, object and profile elements, and is indicated by using the base, rather than the name, attribute. The base attribute specifies the name of the existing item that is to be modified.</p>
<p>The syntax for modifying an item is the same as for creating an item, but there are rules. These rules are not specified in the DM Schema.</p>
<h4 id="a.2.12.1-parameter-modifications">A.2.12.1 Parameter Modifications</h4>
<p>The following rules govern parameter modifications.</p>
<p>Table 22 – XML Parameter Modification</p>
<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>access</td>
<td>Can be “promoted” from readOnly to readWrite.</td>
</tr>
<tr class="even">
<td>status</td>
<td>Can be “promoted” to a “higher” value, where the lowest to highest ordering is: current, deprecated, obsoleted, deleted. For example, current can be changed to deprecated, and obsoleted can be changed to deleted, but deleted cannot be changed back to obsoleted. When promoting status, the deprecation, obsoletion and deletion rules of Section 2.4 MUST be obeyed.</td>
</tr>
<tr class="odd">
<td>activeNotify</td>
<td>Can be changed from forceEnabled to forceDefault. No other changes are permitted.</td>
</tr>
<tr class="even">
<td>forcedInform</td>
<td>Cannot be changed.</td>
</tr>
<tr class="odd">
<td>description</td>
<td>Can be prefixed, extended or replaced via use of the action attribute (A.2.12.6). When changing the description, behavioral backwards compatibility MUST be preserved.</td>
</tr>
<tr class="even">
<td>syntax/hidden</td>
<td>Cannot be changed.</td>
</tr>
<tr class="odd">
<td>syntax/list</td>
<td>Can add or modify the list element in the following ways: · Can convert a non-list string parameter to a list provided that an empty string was already a valid value with the appropriate meaning. · Can adjust limits on numbers of items, and on the list size, provided that the new rules do not permit any values that were not valid for the previous version of the parameter.</td>
</tr>
<tr class="even">
<td>syntax/int etc syntax/dataType</td>
<td>Can make any change that follows the base type restriction rules of A.2.3.8, e.g. can add enumerations.</td>
</tr>
<tr class="odd">
<td>syntax/default</td>
<td>A default can be added if the parameter did not already have one.</td>
</tr>
</tbody>
</table>
<p>Most of the above requirements are non-normative, because it has to be possible to correct errors in a previous version of a parameter. Processing tools SHOULD be able to detect and warn when a parameter is modified in a way that contravenes the above rules.</p>
<h4 id="command-modifications-usp-only">2.12.2 Command Modifications (USP Only)</h4>
<p>The following rules govern command modifications.</p>
<p>Table 23 – XML Command Modification</p>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>async</td>
<td>Can be changed.</td>
</tr>
<tr class="even">
<td>status</td>
<td>Can be “promoted” to a “higher” value, where the lowest to highest ordering is: current, deprecated, obsoleted, deleted. For example, current can be changed to deprecated, and obsoleted can be changed to deleted, but deleted cannot be changed back to obsoleted. When promoting status, the deprecation, obsoletion and deletion rules of Section 2.4 MUST be obeyed.</td>
</tr>
<tr class="odd">
<td>description</td>
<td>Can be prefixed, extended or replaced via use of the action attribute (A.2.12.6). When changing the description, behavioral backwards compatibility MUST be preserved.</td>
</tr>
<tr class="even">
<td>input</td>
<td>Can modify input arguments according to the rules for modifying data model parameters and objects. Can add new input arguments, either directly or by referencing (including) new components.</td>
</tr>
<tr class="odd">
<td>output</td>
<td>Can modify output arguments according to the rules for modifying data model parameters and objects. Can add new output arguments, either directly or by referencing (including) new components.</td>
</tr>
</tbody>
</table>
<p>Most of the above requirements are non-normative, because it has to be possible to correct errors in a previous version of a parameter. Processing tools SHOULD be able to detect and warn when a parameter is modified in a way that contravenes the above rules.</p>
<h4 id="event-modifications-usp-only">2.12.3 Event Modifications (USP Only)</h4>
<p>The following rules govern command modifications.</p>
<p>Table 24 – XML Event Modification</p>
<table>
<colgroup>
<col style="width: 4%" />
<col style="width: 95%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>status</td>
<td>Can be “promoted” to a “higher” value, where the lowest to highest ordering is: current, deprecated, obsoleted, deleted. For example, current can be changed to deprecated, and obsoleted can be changed to deleted, but deleted cannot be changed back to obsoleted. When promoting status, the deprecation, obsoletion and deletion rules of Section 2.4 MUST be obeyed.</td>
</tr>
<tr class="even">
<td>description</td>
<td>Can be prefixed, extended or replaced via use of the action attribute (A.2.12.6). When changing the description, behavioral backwards compatibility MUST be preserved.</td>
</tr>
<tr class="odd">
<td>component</td>
<td>Can add new arguments by referencing (including) new components.</td>
</tr>
<tr class="even">
<td>parameter</td>
<td>Can modify parameter arguments according to the rules for modifying data model parameters. Can add new parameter arguments.</td>
</tr>
<tr class="odd">
<td>object</td>
<td>Can modify object arguments according to the rules for modifying data model objects. Can add new object arguments.</td>
</tr>
</tbody>
</table>
<p>Most of the above requirements are non-normative, because it has to be possible to correct errors in a previous version of a parameter. Processing tools SHOULD be able to detect and warn when a parameter is modified in a way that contravenes the above rules.</p>
<h4 id="a.2.12.4-object-modifications">A.2.12.4 Object Modifications</h4>
<p>The following rules govern object modifications.</p>
<p>Table 25 – XML Object Modification</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 93%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>access</td>
<td>Can be “promoted” from readOnly to readWrite.</td>
</tr>
<tr class="even">
<td>minEntries</td>
<td>Cannot be changed.</td>
</tr>
<tr class="odd">
<td>maxEntries</td>
<td>Cannot be changed.</td>
</tr>
<tr class="even">
<td>numEntriesParameter</td>
<td>Cannot be changed, unless was previously missing, in which case can be added.</td>
</tr>
<tr class="odd">
<td>enableParameter</td>
<td>For CWMP only, cannot be changed, unless was previously missing, in which case can be added.</td>
</tr>
<tr class="even">
<td>status</td>
<td>Can be “promoted” to a “higher” value, where the lowest to highest ordering is: current, deprecated, obsoleted, deleted. For example, current can be changed to deprecated, and obsoleted can be changed to deleted, but deleted cannot be changed back to obsoleted. When promoting status, the deprecation, obsoletion and deletion rules of Section 2.4 MUST be obeyed.</td>
</tr>
<tr class="odd">
<td>description</td>
<td>Can be prefixed, extended or replaced via use of the action attribute (A.2.12.6). When changing the description, behavioral backwards compatibility MUST be preserved.</td>
</tr>
<tr class="even">
<td>uniqueKey</td>
<td>Cannot be changed, but new unique keys can be added.</td>
</tr>
<tr class="odd">
<td>component</td>
<td>Can reference (include) new components.</td>
</tr>
<tr class="even">
<td>parameter</td>
<td>Can add new parameters.</td>
</tr>
<tr class="odd">
<td>command</td>
<td>For USP only, can add new commands.</td>
</tr>
<tr class="even">
<td>event</td>
<td>For USP only, can add new events.</td>
</tr>
</tbody>
</table>
<p>Most of the above requirements are non-normative, because it has to be possible to correct errors in a previous version of an object. Processing tools SHOULD be able to detect and warn when an object is modified in a way that contravenes the above rules.</p>
<h4 id="a.2.12.5-profile-modifications">A.2.12.5 Profile Modifications</h4>
<p>The following rules govern profile modifications. They apply to the profile element, and to its nested parameter, command, event and object elements.</p>
<p>Table 26 – XML Profile Modification</p>
<table>
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>status</td>
<td>Can be “promoted” to a “higher” value, where the lowest to highest ordering is: current, deprecated, obsoleted, deleted. For example, current can be changed to deprecated, and obsoleted can be changed to deleted, but deleted cannot be changed back to obsoleted. When promoting status, the deprecation, obsoletion and deletion rules of Section 2.4 MUST be obeyed.</td>
</tr>
<tr class="even">
<td>description</td>
<td>Can be prefixed, extended or replaced via use of the action attribute (A.2.12.6). When changing the description, behavioral backwards compatibility MUST be preserved.</td>
</tr>
</tbody>
</table>
<p>Most of the above requirements are non-normative, because it has to be possible to correct errors in a profile. Indeed, since profiles are immutable, the only valid reason for changing a profile is to correct errors. Processing tools SHOULD be able to detect and warn when a profile is modified in a way that contravenes the above rules.</p>
<h4 id="a.2.12.6-description-modifications">A.2.12.6 Description Modifications</h4>
<p>The following rules govern description modifications. They apply to all description elements.</p>
<p>Table 27 – XML Description Modification</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>action</td>
<td>Determines how the description will be modified; allowed values are: <br>- create: create a new description (this is the default but is of course not permitted when modifying a description). <br>- replace: replace the existing description with the new text. <br>- append: append the new text to the existing description. <br>- prefix: prefix the existing description with the new text.<br><br></td>
</tr>
</tbody>
</table>
<p>In the case of <strong>prefix</strong> and <strong>append</strong>, processing tools SHOULD insert a line break between the existing description and the new text.</p>
<h2 id="a.3-dm-schema">A.3 DM Schema</h2>
<p>The normative version of the DM Schema can be found at <a href="http://www.broadband-forum.org/cwmp/cwmp-datamodel-1-6.xsd" class="uri">http://www.broadband-forum.org/cwmp/cwmp-datamodel-1-6.xsd</a>. Please be aware that a new version of the DM Schema might be published at any time, in which case the version referenced in this document would become out of date. Any conflict MUST be resolved in favor of the normative version on the web site.</p>
<h1 id="annex-b.-cwmp-device-type-xml-schema">Annex B. CWMP Device Type XML Schema</h1>
<h2 id="b.1-introduction">B.1 Introduction</h2>
<p>The CWMP Device Type XML Schema 9, or DT Schema, is used for describing a device’s supported data model.</p>
<p>DT Schema instance documents can contain the following:</p>
<ul>
<li><p>Imports (from DM Schema instance documents) of Root or Service Object definitions</p></li>
<li><p>Declarations of which features of imported Root or Service Objects are supported</p></li>
</ul>
<p>DT Schema instance documents cannot contain definitions of Root or Service Objects. All such definitions have to reside in DM Schema instance documents.</p>
<h2 id="b.2-normative-information">B.2 Normative Information</h2>
<p>It is possible to create instance documents that conform to the DT Schema but nevertheless are not valid device type specifications. This is because it is not possible to specify all the normative device type specification requirements using the XML Schema language. Therefore, the schema contains additional requirements written using the usual normative language. Instance documents that conform to the DT Schema and meet these additional requirements are referred to as DT Instances.</p>
<p>The question of the location of the definitive normative information therefore arises. The answer is as follows:</p>
<ul>
<li><p>All the normative information in the main part of the document remains normative.</p></li>
<li><p>The DT Schema, and the additional requirements therein, are normative. Some of these additional requirements are duplicated (for emphasis) in this Annex.</p></li>
<li><p>The DT Schema references additional material in this Annex. Such material is normative.</p></li>
<li><p>If the DT Schema conflicts with a normative requirement in the main part of the document, this is an error in the DT Schema, and the requirement in the main part of the document takes precedence.</p></li>
</ul>
<h3 id="b.2.1-importing-dm-instances">B.2.1 Importing DM Instances</h3>
<p>DM Instances are imported using the top-level import element, which differs from the DM Schema import element in that only data types and models can be imported (components cannot be imported because they are not used in DT Instances).</p>
<p>Note – the rules for importing DM Instances into DT Instances are consistent with those given in A.2.1 for importing DM Instances into other DM Instances. The only difference is an additional rule governing the use, when available, of the DT Instance URL.</p>
<p>The DT Schema specifies that the DM Instance is located via the file attribute.</p>
<p>The rules governing the file attribute’s value and its use for locating the DM Instance are as follows:</p>
<ul>
<li><p>It MUST be a URL adhering to RFC 3986 5.</p></li>
<li><p>If the URL includes a scheme, it MUST be http, https or ftp.</p></li>
<li><p>If the URL includes an authority, it MUST NOT include credentials.</p></li>
<li><p>For standard BBF DM Instances, the rules that apply to the filename part (final path segment) of the A.2.1.1 BBFURL MUST be applied to the filename part of this URL. This means that the corrigendum number can be omitted in order to refer to the latest corrigendum.</p></li>
<li><p>If the URL is a relative reference, processing tools MUST apply their own logic, e.g. apply a search path. If a DT Instance URL is available, the relative reference MUST be interpreted relative to the DT Instance URL.</p></li>
</ul>
<h3 id="b.2.2-features">B.2.2 Features</h3>
<p>The feature element provides a simple way for a DT Instance to indicate whether a given feature is supported. The current set of standard features is as follows:</p>
<table>
<thead>
<tr class="header">
<th>Feature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DNSClient</td>
<td>Device contains a DNS client.</td>
</tr>
<tr class="even">
<td>DNSServer</td>
<td>Device contains a DNS server.</td>
</tr>
<tr class="odd">
<td>Firewall</td>
<td>Device contains a firewall.</td>
</tr>
<tr class="even">
<td>IPv6</td>
<td>Device supports IPv6.</td>
</tr>
<tr class="odd">
<td>NAT</td>
<td>Device supports NAT.</td>
</tr>
<tr class="even">
<td>Router</td>
<td>Device is a router.</td>
</tr>
</tbody>
</table>
<p>Vendor-specific features MAY be supported, and if so the feature name MUST begin with <code>X_&lt;VENDOR&gt;_</code>, where <code>&lt;VENDOR&gt;</code> MUST be as defined in Section 3.3.</p>
<p>This example feature declaration illustrates the use of annotation:</p>
<pre><code>&lt;feature name=&quot;DNSServer&quot;&gt;

  &lt;annotation&gt;Supports a DNS Server and XYZ.&lt;/annotation&gt;

&lt;/feature&gt;</code></pre>
<h4 id="b.2.2.1-dt-features-schema">B.2.2.1 DT Features Schema</h4>
<p>In order to make it easy to add new features, standard feature names are defined in a separate DT Features Schema that is imported by the DT Schema. The DT Features Schema is unversioned, so the DT Schema need not be changed when new standard feature names are added. In order to preserve backwards compatibility, standard feature names, once added, MUST NOT ever be deleted.</p>
<p>The normative version of the DT Features Schema can be found at <a href="http://www.broadband-forum.org/cwmp/cwmp-devicetype-features.xsd" class="uri">http://www.broadband-forum.org/cwmp/cwmp-devicetype-features.xsd</a>. Please be aware that a new version of the DT Features Schema might be published at any time, in which case the version referenced in this document would become out of date. Any conflict MUST be resolved in favor of the normative version on the web site.</p>
<h2 id="b.3-dt-schema">B.3 DT Schema</h2>
<p>The normative version of the DT Schema can be found at <a href="http://www.broadband-forum.org/cwmp/cwmp-devicetype-1-3.xsd" class="uri">http://www.broadband-forum.org/cwmp/cwmp-devicetype-1-3.xsd</a>. Please be aware that a new version of the DT Schema might be published at any time, in which case the version referenced in this document would become out of date. Any conflict MUST be resolved in favor of the normative version on the web site.</p>
<h1 id="annex-c---requirements-for-bbf-standard-data-models">Annex C - Requirements for BBF Standard Data Models</h1>
<h2 id="c.1-introduction">C.1 Introduction</h2>
<p>This Annex defines requirements that apply to all standard BBF DM Instances. These requirements extend the normative requirements of the DM Schema (Annex A).</p>
<h2 id="c.2-character-encoding-and-character-set">C.2 Character Encoding and Character Set</h2>
<p>The file MUST use UTF-8 encoding, indicated by the following Initial line:</p>
<pre><code>  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></pre>
<p>The file MUST use only a subset of the printable characters in the Basic Latin Unicode block, namely characters whose decimal ASCII representation is 10 (<code>#xA</code>), 13 (<code>#xD</code>) or is in the (inclusive) range 32-126.</p>
<p><em>Note – writing LF (LINE FEED) for <code>#xA</code> and <code>CR</code> (CARRIAGE RETURN) for <code>#xD</code>, section 2.11 of the XML specification</em> <em>6 states that XML processors have to behave as if all CR LF sequences, or any CR characters not followed by LF, are translated to LF.</em></p>
<p><em>Note – TAB (<code>#x9</code>) is not permitted. This is because no standard indentation level is defined for TAB characters, so the indentation is ambiguous when there is a mixture of SPACE <code>(#x20</code>) and TAB characters.</em></p>
<p><em>Note – it is not permissible to include a non-printable ASCII character by using a character reference such as “<code>&amp;#xe8;</code>”. Such a character reference will always be replaced with the referenced character before being passed to the application, so use of the reference is no different from direct use of the referenced character (in this case the letter “è”, an “e” with a grave accent).</em></p>
<h2 id="c.3-xml-usage">C.3 XML Usage</h2>
<h3 id="c.3.1-data-model-item-names">C.3.1 Data Model Item Names</h3>
<p>All data model item names, i.e. data type, component, data model, object, parameter and profile names, MUST start with an upper-case letter (or an underscore for an internal data type, component or model name) and MUST NOT contain hyphens or non-initial underscores.</p>
<h3 id="c.3.2-dm-and-dmr-schema-versions">C.3.2 DM and DMR Schema Versions</h3>
<p>The file SHOULD use the most recent approved versions of the DM and DMR Schemas.</p>
<p><em>Note – the DMR Schema is a non-normative XML Schema that can be used to give hints to processing tools that generate reports from DM Instances.</em></p>
<h3 id="c.3.3-schemalocation-attribute">C.3.3 SchemaLocation Attribute</h3>
<p>The top-level <code>xsi:schemaLocation</code> attribute defines the location of all of the referenced BBF-published XML Schemas. All URLs MUST be absolute ones that reference the published XML Schema on the <a href="https://cwmp-data-models.broadband-forum.org">BBF web site</a>.</p>
<p>Example:</p>
<pre><code>xsi:schemaLocation=&quot;urn:broadband-forum-org:cwmp:datamodel-1-5
                      http://www.broadband-forum.org/cwmp/cwmp-datamodel-1-5.xsd
                    urn:broadband-forum-org:cwmp:datamodel-report-0-1
                      http://www.broadband-forum.org/cwmp/cwmp-datamodel-report.xsd&quot;</code></pre>
<h3 id="c.3.4-spec-attribute">C.3.4 Spec Attribute</h3>
<p>The top-level spec attribute (A.2.1.1) indicates the specification with which the file is associated. It MUST be of the form “urn:broadband-forum-org:tr-nnn-i-a-c”, where nnn is the specification number (including leading zeros), i is the issue number, a is the amendment number, and c is the corrigendum number. The issue, amendment and corrigendum numbers do not include leading zeros. For example, “urn:broadband-forum-org:tr-106-1-0-0” refers to TR-106 (Issue 1 Amendment 0), and “urn:broadband-forum-org:tr-106-1-2-1” refers to TR-106 (Issue 1) Amendment 2 Corrigendum 1.</p>
<p>Example:</p>
<pre><code>spec=&quot;urn:broadband-forum-org:tr-181-2-5-0&quot;</code></pre>
<h3 id="c.3.5-file-attribute">C.3.5 File Attribute</h3>
<p>The top-level file attribute (A.2.1.1) indicates the file name. It MUST be of the form “tr-nnn-i-a-c.xml” or “tr-nnn-i-a-c-label.xml”, where nnn, i, a and c are the same as in the spec attribute. The label, which MUST NOT begin with a digit, is only needed if more than one DM Instance is associated with a given specification.</p>
<p>Example:</p>
<pre><code>file=&quot;tr-181-2-5-0.xml&quot;</code></pre>
<h3 id="c.3.6-import-element">C.3.6 Import Element</h3>
<p>The import element’s spec and file attributes MUST NOT specify the corrigendum number. This means that an import element always references the latest corrigendum (A.2.1.1).</p>
<h3 id="c.3.7-bibliography-reference-element">C.3.7 Bibliography Reference Element</h3>
<p>The bibliography reference id attribute is intended to uniquely identify this reference across all instance documents. Therefore, this attribute MUST obey the following rules:</p>
<p>For a BBF Technical Report, it MUST be of the form “TR-nnnixaycz”, where TR is the literal “TR”, nnn is the Technical Report number (including leading zeros), i, a and c are literal letters, and x, y, and z are the issue, amendment and corrigendum numbers respectively. The issue number (ix) is omitted if it is issue 1 and the amendment number (ay) is omitted if it is amendment 0. For example, “TR-106a2” refers to TR-106 (Issue 1) Amendment 2. If the corrigendum number (cz) is omitted, the most recent corrigendum is assumed.</p>
<p>For an IETF RFC, it MUST be of the form “RFCnnn”, where RFC is the literal “RFC” and nnn is the RFC number (no leading zeros).</p>
<p>For an IEEE specification, it SHOULD be of the form “nnn.ml-dddd”, where nnn.m is the IEEE group, l is the spec letter(s), and dddd is the publication year. For example, “802.1D-2004”.</p>
<p>For an ETSI specification (which includes DVB specifications), it SHOULD be of the form “TTnnnnnnva.b.c” where TT is the specification type, usually “TS” (Technical Specification), nnnnnn is the specification number, and a.b.c is the version number.</p>
<p>For specifications issued by other standards organizations, or by vendors, it SHOULD be of a standard form if one is defined.</p>
<p>Formally, bibliographic reference IDs in instance documents that are published by the BBF and the other organizations mentioned above are defined as follows:</p>
<pre><code>ReferenceID = BBFID
            | RFCID
            | IEEEID
            | ETSIID
            | OtherID

BBFID = &quot;TR-&quot; BBFNumber BBFIssue BBFAmendment BBFCorrigendum

BBFNumber = DIGIT{3,} // including leading zeros, e.g. 069

BBFIssue = &quot;i&quot; &lt;number greater than one&gt;
         | &quot;&quot; // empty means Issue 1

BBFAmendment = &quot;a&quot; &lt;number greater than zero&gt;
             | &quot;&quot; // empty means Amendment 0

BBFCorrigendum = &quot;c&quot; &lt;number greater than zero&gt;
               | &quot;&quot; // empty means the most recent Corrigendum

RFCID = &quot;RFC&quot; RFCNumber

RFCNumber = NONZERODIGIT [DIGIT]*
                          // no leading zeros, e.g. 123

IEEEID = IEEEGroup IEEESpec IEEEDate
       | &lt;for other IEEE specifications, of a standard form if one is defined&gt;

IEEEGroup = &lt;group number&gt; &quot;.&quot; &lt;group sub-number&gt;
                            // e.g. 802.1

IEEESpec = &lt;spec letter(s)&gt; // e.g. D

IEEEDate = &quot;-&quot; &lt;publication year&gt;
                            // e.g. -2004
         | &quot;&quot;               // can be empty

ETSIID = ETSISpecType ETSINumber ETSIVersion
       | &lt;for other ETSI specifications, of a standard form if one is defined&gt;

ETSISpecType = &quot;TR&quot; // Technical Report
             | &quot;TS&quot; // Technical Specification
             | &quot;ES&quot; // ETSI Specification
             | &quot;EN&quot; // European Standard

ETSINumber = [DIGIT]{6} // e.g. 102034

ETSIVersion = &quot;v&quot; &lt;version number as specified by ETSI&gt;
            | &quot;&quot;            // can be empty

OtherURI = &lt;of a standard form if one is defined&gt;</code></pre>
<h3 id="c.4-general-formatting">C.4 General Formatting</h3>
<p>The file MUST use 2 SPACE characters for indentation.</p>
<p>The file MUST be consistently indented, including within XML comments.</p>
<p>XML comment lines SHOULD NOT be longer than 79 characters. This avoids line wrap in most text editors.</p>
<p>All description elements MUST be formatted as follows:</p>
<ul>
<li><p>Single-line descriptions MAY be indented and formatted on separate lines (as for multi-line descriptions) or inline, as in:</p>
<p><description>One line description.</description></p></li>
<li><p>Multi-line descriptions MUST be indented relative to the description element and formatted on separate lines, as in:</p>
<p><description> First line of multi-line description. Second line of multi-line description. </description></p></li>
</ul>
<h2 id="c.5-initial-xml-comment-formatting">C.5 Initial XML Comment Formatting</h2>
<p>The Initial Line (the <code>&lt;?xml&gt;</code> line) MUST be immediately followed by an Initial XML comment that consists of the following (separated by blank lines):</p>
<ul>
<li><p>One-line summary.</p></li>
<li><p>Notice section.</p></li>
<li><p>Summary section.</p></li>
<li><p>Issue History section.</p></li>
</ul>
<p>The three sections MUST be introduced by a line that consists of two SPACE characters followed by the section name and a colon.</p>
<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!--
      ...One-line summary...

    Notice:
      ...standard notice...

    Summary:
      ...multi-line summary...

    Issue History:
      ...summary of changes in each approved version...

    --&gt;</code></pre>
<h3 id="c.5.1-one-line-summary">C.5.1 One-line Summary</h3>
<p>The One-line summary MUST contain a brief description of the reason for the creation of this version. It SHOULD NOT be terminated with a period (it is not a sentence).</p>
<p>Example:</p>
<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!--
      Added support for IPsec</code></pre>
<h3 id="c.5.2-summary-section">C.5.2 Summary Section</h3>
<p>The Summary section MAY extend the information in the One-line summary.</p>
<h1 id="appendix-i---html-data-model-reports">Appendix I - HTML Data Model Reports</h1>
<h2 id="i.1-introduction">I.1 Introduction</h2>
<p>TR-106 Amendment 2 published the first version of the DM Schema. Since then the normative definitions of all CWMP data models have been published as DM Instances (XML documents that conform to the DM Schema). Since these XML data models might not be easily read by a human, corresponding non-normative HTML data model reports have also been published.</p>
<p>This appendix briefly discusses these HTML reports.</p>
<h2 id="i.2-report-types">I.2 Report Types</h2>
<p>There are two types of HTML reports published for a given version of a data model:</p>
<ul>
<li><p>a full report, covering the given version and all preceding versions of the data model</p></li>
<li><p>a partial report, covering only the given version of the data model (i.e. excluding content specific to earlier versions of the data model); i.e. last only changes</p></li>
</ul>
<p>For example, TR-181 Issue 2 Amendment 11 defined the Device:2.11 data model revision, declared in tr-181-2-11-0.xml. The full report is in tr-181-2-11-0.html, and includes the aggregate data model definitions from Device:2.11 and earlier (back to Device:2.0 inclusive). The partial report is in tr-181-2-11-0-diffs.html, and only includes the data model definitions added or changed by TR-181 Issue 2 Amendment 11.</p>
<h2 id="i.3-report-layout">I.3 Report Layout</h2>
<p>Each HTML data model report contains the following sections:</p>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Notice</th>
<th>The legal notice, lifted from the top of the associated XML data model file.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Summary</td>
<td>Describes the reason for this data model version. This is lifted from the associated XML data model file’s document description.</td>
</tr>
<tr class="even">
<td>Table of Contents</td>
<td>Hyperlinks to the various sections within the report, as well as links to each Object and Profile definition within the report.</td>
</tr>
<tr class="odd">
<td>Data Types</td>
<td>Named data type definitions (i.e. not built-in types) that are used to define Parameters within the report. Each data type definition consists of name, type, and description.</td>
</tr>
<tr class="even">
<td>References</td>
<td>Hyperlinks to external bibliography references cited by Object, Parameter, and Profile descriptions within the report.</td>
</tr>
<tr class="odd">
<td>Data model definition</td>
<td>Object and Parameter definitions. Which Object and Parameter definitions are included depends on whether it is a full or partial (last only) report.</td>
</tr>
<tr class="even">
<td>Inform and Notification Requirements</td>
<td>Lists those Parameters within the report that are: forced inform parameters, forced active notification parameters, and parameters for which active notification can be denied.</td>
</tr>
<tr class="odd">
<td>Profile Definitions</td>
<td>Profile definitions, showing Object and Parameter requirements. Which Profiles are included depends on whether it is a full or partial (last only) report.</td>
</tr>
</tbody>
</table>
<h2 id="i.4-data-model-definition">I.4 Data Model Definition</h2>
<p>Parameters make use of a limited subset of the default SOAP data types. The notation used to represent these types within the report is listed in the following table.</p>
<table>
<colgroup>
<col style="width: 3%" />
<col style="width: 96%" />
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>object</td>
<td>A container for parameters and/or other objects. The full Path Name of a parameter is given by the parameter name appended to the full Path Name of the object it is contained within.</td>
</tr>
<tr class="even">
<td>string</td>
<td>For strings, a minimum and maximum allowed length can be indicated using the form string(Min:Max), where Min and Max are the minimum and maximum string length in characters. If either Min or Max are missing, this indicates no limit, and if Min is missing the colon can also be omitted, as in string(Max). Multiple comma-separated ranges can be specified, in which case the string length will be in one of the ranges.</td>
</tr>
<tr class="odd">
<td>int</td>
<td>Integer in the range –2147483648 to +2147483647, inclusive. For some int types, a value range is given using the form int(Min:Max) or int(Min:Max step Step) where the Min and Max values are inclusive. If either Min or Max are missing, this indicates no limit. If Step is missing, this indicates a step of 1. Multiple comma-separated ranges can be specified, in which case the value will be in one of the ranges.</td>
</tr>
<tr class="even">
<td>long</td>
<td>Long integer in the range –9223372036854775808 to 9223372036854775807, inclusive. For some long types, a value range is given using the form long(Min:Max) or long(Min:Max step Step), where the Min and Max values are inclusive. If either Min or Max are missing, this indicates no limit. If Step is missing, this indicates a step of 1. Multiple comma-separated ranges can be specified, in which case the value will be in one of the ranges.</td>
</tr>
<tr class="odd">
<td>unsignedInt</td>
<td>Unsigned integer in the range 0 to 4294967295, inclusive. For some unsignedInt types, a value range is given using the form unsignedInt(Min:Max) or unsigned(Min:Max step Step), where the Min and Max values are inclusive. If either Min or Max are missing, this indicates no limit. If Step is missing, this indicates a step of 1.Multiple comma-separated ranges can be specified, in which case the value will be in one of the ranges.</td>
</tr>
<tr class="even">
<td>unsignedLong</td>
<td>Unsigned long integer in the range 0 to 18446744073709551615, inclusive. For some unsignedLong types, a value range is given using the form unsignedLong(Min:Max) or unsignedLong(Min:Max step Step), where the Min and Max values are inclusive. If either Min or Max are missing, this indicates no limit. If Step is missing, this indicates a step of 1. Multiple comma-separated ranges can be specified, in which case the value will be in one of the ranges.</td>
</tr>
<tr class="odd">
<td>boolean</td>
<td>Boolean, where the allowed values are “0” or “1” (or equivalently, “true” or “false”).</td>
</tr>
<tr class="even">
<td>dateTime</td>
<td>The subset of the ISO 8601 date-time format defined by the SOAP dateTime type.</td>
</tr>
<tr class="odd">
<td>base64</td>
<td>Base64 encoded binary (no line-length limitation). A minimum and maximum allowed length can be indicated using the form base64(Min:Max), where Min and Max are the minimum and maximum length in characters before Base64 encoding. If either Min or Max are missing, this indicates no limit, and if Min is missing the colon can also be omitted, as in base64(Max). Multiple comma-separated ranges can be specified, in which case the length MUST be in one of the ranges.</td>
</tr>
<tr class="even">
<td>hexBinary</td>
<td>Hex encoded binary. A minimum and maximum allowed length can be indicated using the form hexBinary(Min:Max), where Min and Max are the minimum and maximum length in characters before Hex Binary encoding. If either Min or Max are missing, this indicates no limit, and if Min is missing the colon can also be omitted, as in hexBinary(Max). Multiple comma-separated ranges can be specified, in which case the length MUST be in one of the ranges.</td>
</tr>
</tbody>
</table>
<p>Note: A Parameter that is defined to be one of the named data types, is reported as such at the beginning of the Parameter’s description via a reference back to the associated data type definition (e.g. [MacAddress]). However, such parameters still indicate their SOAP data type (as discussed in the table above).</p>
<p><strong>End of Broadband Forum Technical Report TR-106</strong></p>
</body>
</html>
